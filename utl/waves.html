<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Physics Sandbox 3D (Refactored)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --color-bg-dark: #000000;
            --color-bg-medium: #09070e;
            --color-bg-light: #13071f;
            --color-border: #26112b;
            --color-text: #c2bfd4;
            --color-active: #8bafcc;
            --color-warning: #e5b300;
            --color-danger: #622;
            --color-probe: #e568b2;
            --color-valve: #9d26cc;
            --color-valve-open: #008cff;
            --spacing-unit: 4px;
            --border-width: 2px;
            --font-size: 12px;
            --input-height: 22px;
            --color-slider-track: #1a203f;
            --color-slider-thumb: #cddaff;
            --color-slider-progress: #794a4a;
            --toolbar-height: 32px;
            --sidebar-width: 320px;
            --input-padding: 4px 2px;
            --marker-start: 0%;
            --marker-end: 100%;
        }

        body {
            margin: 0;
            font-family: "Inter", sans-serif;
            background: var(--color-bg-dark);
            color: var(--color-text);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
            font-size: var(--font-size);
        }

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--color-bg-medium);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--color-border);
            border-radius: 0px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--color-active);
        }

        #app-container {
            display: flex;
            flex-grow: 1;
            width: 100%;
            height: calc(100vh - var(--toolbar-height));
        }

        #top-toolbar {
            height: var(--toolbar-height);
            background: var(--color-bg-medium);
            border-bottom: 0px solid #000;
            display: flex;
            align-items: center;
            padding: 0 8px;
            gap: 4px;
        }

        #top-toolbar button {
            width: auto;
            padding: 0px 12px;
        }

        #sidebar {
            width: var(--sidebar-width);
            background: var(--color-bg-medium);
            padding: 8px;
            overflow-y: auto;
            border-right: 0px solid #000;
            display: flex;
            flex-direction: column;
            gap: 8px;
            resize: horizontal;
            min-width: 320px;
            max-width: 600px;
        }

        #canvas-container {
            flex-grow: 1;
            position: relative;
            cursor: crosshair;
            overflow: hidden;
        }


        select {
            background: var(--color-bg-light);
            color: var(--color-text);
            border: 0px solid var(--color-border);
            width: 100%;
            font-family: inherit;
            font-size: 12px;
            padding: var(--input-padding);
            margin-top: 4px;
            margin-bottom: 4px;
            box-sizing: border-box;
            border-radius: 0px;
        }

        input {
            background: var(--color-bg-light);
            color: var(--color-text);
            width: 98%;
            font-family: inherit;
            font-size: 11px;
            padding: var(--input-padding);
            height: 12px;
            box-sizing: border-box;
            border-radius: 0px;
        }

        button {
            background: var(--color-bg-light);
            color: var(--color-text);
            border: 0px solid var(--color-border);
            width: 100%;
            font-family: inherit;
            font-size: 12px;
            padding: var(--input-padding);
            height: 20px;
            box-sizing: border-box;
            border-radius: 0px;
        }

        textarea {
            background: var(--color-bg-light);
            color: var(--color-text);
            border: 0px solid var(--color-border);
            width: 100%;
            font-family: inherit;
            font-size: 11px;
            padding: var(--input-padding);
            height: 18px;
            box-sizing: border-box;
            border-radius: 0px;
        }

        textarea {
            height: 60px;
            resize: vertical;
            line-height: 1.2;
        }

        input:focus,
        select:focus,
        textarea:focus {
            outline: 1px solid var(--color-active);
            border-color: var(--color-active);
        }

        input[type="range"] {          
            margin: 2px;
            cursor: grab;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: var(--color-slider-track);
            border-radius: 0px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 8px;
            height: 8px;
            background: var(--color-slider-thumb);
            border: 0px solid #000;
            border-radius: 0%;
            cursor: pointer;
            margin-top: -2px;
        }

        .value-label {
            font-family: monospace;
            font-size: 12px;
            font-weight: normal;
            color: var(--color-active);
            min-width: 40px;
            display: inline-block;
            text-align: right;
            padding-bottom: 4px;

        }

        button {
            cursor: pointer;
            font-weight: 600;
            transition: background 0.1s;
            border-radius: 0px;
        }

        button:hover {
            background: #4f5861;
        }

        button:active {
            background: #222;
        }

        button.active {
            background: var(--color-active);
            color: var(--color-bg-medium);
            border-color: #000;
        }

        button.probe-active {
            background: var(--color-probe);
            border-color: var(--color-probe);
            color: var(--color-bg-dark);
        }

        button.valve-active {
            background: var(--color-valve);
            border-color: var(--color-valve);
            color: var(--color-bg-dark);
        }

        .row {
            display: flex;
            gap: 8px;
            padding-top: 2px;
            align-items: center;
        }

        .layer-box {
            border: 2px solid var(--color-border);
            padding: 8px;
            border-radius: 0px;
            background: var(--color-bg-light);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        #ctx-menu,
        #sdf-menu {
            position: fixed;
            background: var(--color-bg-medium);
            border: 1px solid var(--color-active);
            padding: 10px;
            z-index: 1000;
            display: none;
            width: 280px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            border-radius: 6px;
        }

        #sdf-menu {
            cursor: grab;
            top: 50px;
            left: 400px;
        }

        #probe-menu {
            position: fixed;
            top: var(--toolbar-height);
            right: 8px;
            z-index: 1001;
            background: var(--color-bg-medium);
            border: 1px solid var(--color-probe);
            padding: 8px;
            width: 400px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            border-radius: 0 0 4px 4px;
            display: none;
            cursor: grab;
        }

        #probe-menu h3 {
            color: var(--color-probe);
            cursor: grab;
            margin-top: 0;
        }

        #probe-graph-canvas {
            background: #111;
            border: 1px solid var(--color-border);
            border-radius: 4px;
            margin-bottom: 8px;
        }

        #emit-menu {
            position: fixed;
            top: var(--toolbar-height);
            left: var(--sidebar-width);
            z-index: 1001;
            background: var(--color-bg-medium);
            border: 1px solid var(--color-active);
            padding: 8px;
            width: 260px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            border-radius: 0 0 4px 4px;
            cursor: grab;
        }

        #emit-menu h3 {
            cursor: grab;
            margin-top: 0;
        }

        #valve-menu {
            position: fixed;
            top: var(--toolbar-height);
            left: var(--sidebar-width);
            z-index: 1001;
            background: var(--color-bg-medium);
            border: 1px solid var(--color-valve);
            padding: 8px;
            width: 260px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            border-radius: 0 0 4px 4px;
            cursor: grab;
            display: none;
        }

        #valve-menu h3 {
            color: var(--color-valve);
            cursor: grab;
            margin-top: 0px;
        }

        label {
            font-size: 12px;
            color: #ad5e8a;
            font-weight: bold;
        }

        h3,
        h4 {
            margin: 2px 0 2px 0;
            font-size: 12px;
            border-bottom: 0px solid var(--color-border);
            padding-bottom: 8px;
            color: #ffbee6;
        }

        h3:first-child {
            margin-top: 0px;
            
        }

        #err {
            color: #ff6b6b;
            font-size: 11px;
            min-height: 14px;
            font-weight: bold;
            margin: 8px;
        }

        .color-picker-row {
            display: flex;
            gap: 4px;
            align-items: center;
            justify-content: space-between;
            margin: 4px;
        }

        .color-picker-row input[type="color"] {
            width: 60px;
            height: 20px;
            padding: 2px;
            border: none;
            cursor: pointer;
        }

        #sdf-preview {
            border: 1px solid var(--color-border);
            margin-bottom: 8px;
            background: #000;
            width: 100%;
            height: auto;
            aspect-ratio: 1;
            border-radius: 4px;
        }

        .expandable-header {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px;
            margin-top: 6px;
            border-bottom: 1px solid var(--color-border);
            font-weight: bold;
            color: #615088;
            background-color: #12041b;
            font-size: 13px;
        }

        .expandable-content {
            overflow: hidden;
            transition: max-height 0.1s ease-out;
            max-height: 0;
            padding-bottom: 0;
        }

        .expandable-content.expanded {
            max-height: 1500px;
            padding-bottom: 4px;
            padding-top: 8px;
        }

        .expand-arrow {
            transition: transform 0.1s ease;
        }

        .expanded .expand-arrow {
            transform: rotate(90deg);
        }

        .coupling-link {
            border: 1px solid var(--color-border);
            padding: 6px;
            margin-bottom: 4px;
            border-radius: 4px;
            background: var(--color-bg-light);
        }

        .coupling-link label {
            display: block;
            margin-top: 4px;
            font-size: 11px;
            text-transform: none;
            font-weight: normal;
            color: #dd95cb;
        }

        .coupling-link select {
            width: calc(50% - 2px);
            display: inline-block;
        }

        body.cinematic-mode #sidebar,
        body.cinematic-mode #ctx-menu,
        body.cinematic-mode #sdf-menu,
        body.cinematic-mode #emit-menu,
        body.cinematic-mode #valve-menu,
        body.cinematic-mode #probe-menu,
        body.cinematic-mode #top-toolbar {
            display: none !important;
        }

        body.cinematic-mode #canvas-container {
            cursor: none;
            width: 100%;
            height: 100%;
            max-width: none;
        }

        body.cinematic-mode #app-container {
            height: 100vh;
        }

        .marker-slider {
            height: 10px;
            margin: 0;
            padding: 0;
            -webkit-appearance: none;
            background: linear-gradient(to right,
                    rgba(229, 104, 178, 0.2) 0%,
                    rgba(229, 104, 178, 0.2) var(--marker-start),
                    var(--color-probe) var(--marker-start),
                    var(--color-probe) var(--marker-end),
                    rgba(229, 104, 178, 0.2) var(--marker-end),
                    rgba(229, 104, 178, 0.2) 100%);
            border: 1px solid var(--color-probe);
            border-radius: 5px;
        }

        .marker-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--color-probe);
            border: 2px solid #000;
            border-radius: 50%;
            cursor: pointer;
            margin-top: -3px;
        }
    </style>
</head>

<body oncontextmenu="return false;">
    <div id="top-toolbar">
        <button
        id="btn-toggle-play"
        style="
          width: 100px;
          background: var(--color-warning);
          border-color: var(--color-warning);
        "
      >
        Pause
      </button>
        <button id="btn-toggle-ui">Cinematic Mode (F3)</button>

        <div id="volume-mode-toggle" class="row">
            <button id="btn-vol" style="background: #2b4455; border-color: #4a7a9c">
          Enter 3D Mode
        </button>
            <div id="vol-controls-toolbar" class="row" style="display: none; gap: 4px">
                <label style="color: var(--color-active); margin-right: 4px"
            >Volume Active</label>
                <button id="btn-exit-vol" style="background: #555">
            Exit 3D Mode
          </button>
            </div>
        </div>

        <div id="camera-controls" class="row">
            <button id="btn-cam-top">Top View</button>
            <div id="3d-cam-controls" class="row" style="display: none">
                <button id="btn-cam-left">Left</button>
                <button id="btn-cam-right">Right</button>
                <button id="btn-cam-bottom">Bottom</button>
            </div>
        </div>
    </div>
    <div id="app-container">
        <div id="sidebar">
            <h4 style="
            margin-top: 2px;
            border-bottom: none;
            padding-bottom: 0;
            color: #9cf;
          ">
                Global Controls
            </h4>
            <div class="row">
                <button
            id="btn-clear"
            style="width: 50%; background: #323; border-color: #999"
          >
            Clear Waves
          </button>
                <button
            id="btn-reset-density"
            style="width: 50%; background: #323; border-color: #999"
          >
            Reset Density
          </button>
            </div>
            <div class="row" style="margin-bottom: 8px">
                <button
            id="btn-reset-settings"
            style="width: 50%; background: #323; border-color: #b88"
          >
            Reset View/Settings
          </button>
                <button
            id="btn-full-reset"
            style="
              width: 50%;
              background: #323;
              border-color: #323;
            "
          >
            Full Reset All
          </button>
            </div>

            <h4 style="margin-top: 10px; border-bottom: none; padding-bottom: 0">
                Interaction Tools
            </h4>
            <div class="row" style="margin-top: 2px">
                <button id="b-dist" class="active" data-brush="DISTURBANCE">
            Impulse
          </button>
                <button id="b-emit" data-brush="EMITTER_PLACE">Emitter</button>
                <button id="b-valve" data-brush="VALVE_PLACE">
            Valve
          </button>
                <button id="b-den" data-brush="DENSITY_PAINT">Paint</button>
                <button id="b-sdf" data-brush="SDF_PLACE">Stamp</button>
            </div>

            <div id="brush-controls-group">
                <div class="expandable-header" data-target="brush-controls-content">
                    Brush Controls <span class="expand-arrow">&#x25B8;</span>
                </div>
                <div id="brush-controls-content" class="expandable-content expanded">
                    <div id="dynamic-brush-controls"></div>
                </div>
            </div>

            <div id="custom-model-group">
                <div class="expandable-header" data-target="custom-model-content">
                    Custom Model Editor <span class="expand-arrow">&#x25B8;</span>
                </div>
                <div id="custom-model-content" class="expandable-content">
                    <label>Formula Name</label>
                    <input
              type="text"
              id="custom-name"
              value="My Custom Model"
              style="height: auto; padding: 4px"
            />
                    <label style="margin-top: 8px"
              >Custom Variables (e.g., G=0.01; R=0.5;)</label>
                    <textarea
              id="custom-vars"
              placeholder="G=0.01; NL=5.0;..."
            ></textarea>
                    <label style="margin-top: 8px">Formula Code (u_next = ...;)</label>
                    <textarea
              id="custom-code"
              placeholder="(2*U_CURR - U_PREV) + C_final*LAP*DT2 - D_final*(U_CURR - U_PREV) + G*U_CURR^3;"
            ></textarea>
                    <label style="color: #9cf; margin-top: 8px; font-weight: normal"
              >Vars: U_CURR, U_PREV, LAP, DT_FACTOR, C_final, D_final,
              COUPLING_TERM, EXT_COUPLING, [Custom Vars]</label>
                    <div class="row" style="margin-top: 8px">
                        <button id="btn-test-formula">Test Formula</button>
                        <button id="btn-save-formula">Save Formula</button>
                        <button id="btn-load-formula">Load Formula</button>
                    </div>
                </div>
            </div>

            <div id="global-coupling-group">
                <div class="expandable-header" data-target="global-coupling-content">
                    Coupling Matrix <span class="expand-arrow">&#x25B8;</span>
                </div>
                <div id="global-coupling-content" class="expandable-content">
                    <div id="coupling-links-container"></div>
                    <button id="btn-add-coupling" style="margin-top: 8px">
              + Add Coupling Link
            </button>
                </div>
            </div>

            <div id="global-density-group">
                <div class="expandable-header" data-target="global-density-content">
                    Global Density <span class="expand-arrow">&#x25B8;</span>
                </div>
                <div id="global-density-content" class="expandable-content">
		
		<label>Global Damping: <span id="l-vis" class="value-label">0.000</span></label>
		<input type="range" id="i-vis" min="0.0" max="0.5" value="0.0" step="0.001" />
                    <label
              >Global Density:
              <span id="l-gden-abs" class="value-label">0.000</span></label>
                    <input
              type="range"
              id="i-gden-abs"
              min="0.0"
              max="1.0"
              value="0.0"
              step="0.001"
            />
                    <label
              >Global Refraction:
              <span id="l-gden-ref" class="value-label">1.00</span></label>
                    <input
              type="range"
              id="i-gden-ref"
              min="0.0"
              max="10.0"
              value="1.0"
              step="0.1"
            />
                    <button id="btn-reset-global-den" style="margin-top: 8px">
              Reset Global Density
            </button>
                    <div class="row" style="
                margin-bottom: 8px;
                border-bottom: 1px solid #555;
                padding-bottom: 8px;
              ">
                        <input
                type="checkbox"
                id="cb-show-den"
                checked
                style="width: auto; margin: 0"
              />
                        <label for="cb-show-den" style="margin-left: 4px; color: #fff"
                >Show Density Visuals</label>
                    </div>
                </div>
            </div>

            <div id="view-settings-group">
                <div class="expandable-header" data-target="view-settings-content">
                    Render Settings <span class="expand-arrow">&#x25B8;</span>
                </div>
                <div id="view-settings-content" class="expandable-content">
                    <label>Grid Resolution: <span id="l-res" class="value-label"></span></label><input
              type="range"
              id="i-res"
              min="16"
              max="256"
              value="80"
              step="16"
            />
                    <label
              >Layer Gap: <span id="l-gap" class="value-label">8</span></label><input type="range" id="i-gap" min="1" max="50" value="15" />
                    <label>Visual Wave Height: <span id="l-z" class="value-label">1.0</span></label><input
              type="range"
              id="i-z"
              min="0.0"
              max="10"
              value="1.0"
              step="0.1"
            />

                    <label
              >Clip Height:
              <span id="l-vism" class="value-label">0.00 - 1.00</span></label>
                    <div class="row">
                        <input
                type="range"
                id="i-vis-min"
                min="0"
                max="1"
                step="0.0001"
                value="0.0"
                title="Min Threshold"
              />
                        <input
                type="range"
                id="i-vis-max"
                min="0"
                max="1"
                step="0.0001"
                value="1.0"
                title="Max Threshold"
              />
                    </div>
                    <label
              >Exposure:
              <span id="l-exposure" class="value-label">1.00</span></label>
                    <input
              type="range"
              id="i-exposure"
              min="0.0"
              max="2.0"
              value="1.0"
              step="0.001"
            />
                    <div class="row" style="margin-bottom: 8px">
                        <input
                type="checkbox"
                id="cb-auto-exposure"
                style="width: auto; margin: 0"
              />
                        <label
                for="cb-auto-exposure"
                style="margin-left: 4px; color: #fff"
                >Auto Exposure</label>
                    </div>

                    <label
              >Opacity:
              <span id="l-vo" class="value-label">1.0</span></label>
                    <input
              type="range"
              id="i-vo"
              min="0.01"
              max="1.0"
              value="1.0"
              step="0.01"
            />

                    <h4 style="margin-top: 10px">Reflectivity & Lighting</h4>
                    <label
              >Reflectivity:
              <span id="l-refl" class="value-label">0.80</span></label>
                    <input
              type="range"
              id="i-refl"
              min="0.0"
              max="1.0"
              value="0.8"
              step="0.01"
            />

                    <label
              >Light Intensity:
              <span id="l-li" class="value-label">1.0</span></label><input
              type="range"
              id="i-li"
              min="0.1"
              max="2"
              value="1.0"
              step="0.1"
            />
                    <label>Light Direction</label>
                    <div class="row">
                        <input type="range" id="i-sp" min="0" max="90" value="45" /><input
                type="range"
                id="i-sy"
                min="0"
                max="360"
                value="45"
              />
                    </div>
                </div>
            </div>

            <div id="volume-settings-group-sidebar">
                <div class="expandable-header" data-target="volume-settings-content">
                    Visualization
                    <span class="expand-arrow">&#x25B8;</span>
                </div>
                <div id="volume-settings-content" class="expandable-content">
                    <div id="vol-controls-sidebar" style="
                padding: 4px;
                background: rgba(104, 178, 240, 0.1);
                border-radius: 4px;
                margin-bottom: 8px;
                display: none;
              ">
                        <div class="row" style="margin-top: 4px">
                            <input
                  type="checkbox"
                  id="cb-vol-box"
                  style="width: auto; margin: 0"
                />
                            <label for="cb-vol-box" style="margin-left: 4px"
                  >Show Bounds</label>
                        </div>
                        <div class="row" style="
                  margin-bottom: 8px;
                  border-bottom: 1px solid #555;
                  padding-bottom: 8px;
                ">
                            <div style="
                    display: flex;
                    flex-direction: column;
                    gap: 4px;
                    width: 100%;
                  ">
                                <div class="row">
                                    <input
                      type="checkbox"
                      id="cb-iso"
                      checked
                      style="width: auto; margin: 0; margin-left: 10px"
                    />
                                    <label for="cb-iso" style="margin-left: 4px"
                      >Isotropic</label>
                                </div>
                                <div class="row" style="margin-top: 4px; margin-bottom: 4px;">
                                    <input
      type="checkbox"
      id="cb-vol-absorb"
      style="width: auto; margin: 0"
    />
                                    <label for="cb-vol-absorb" style="margin-left: 4px; color: #fff; width: auto;"
      >Open Boundary</label>
                                </div>
                                <div class="row">
                                    <input
                      type="checkbox"
                      id="cb-mod-alpha"
                      style="width: auto; margin: 0"
                    />
                                    <label
                      for="cb-mod-alpha"
                      style="margin-left: 4px; color: #ddd"
                      >Modulate Opacity (Hide Quiet)</label>
                                </div>
                            </div>
                        </div>

                        <label
                >Z Layers:
                <span id="l-vd" class="value-label">80</span></label>
                        <input
                type="range"
                id="i-vd"
                min="10"
                max="100"
                value="40"
                step="1"
              />

                        <label
                >Point Size:
                <span id="l-psz" class="value-label">1.0</span></label>
                        <input
                type="range"
                id="i-psz"
                min="0.1"
                max="20.0"
                step="0.1"
                value="2.0"
              />

                        <label
                >Point Scaling:
                <span id="l-psc" class="value-label">3.5</span></label>
                        <input
                type="range"
                id="i-psc"
                min="0.0"
                max="10.0"
                step="0.1"
                value="2.0"
              />

                        <label
                >Point Falloff:
                <span id="l-pf" class="value-label">0.0</span></label>
                        <input
                type="range"
                id="i-pf"
                min="0.0"
                max="1.0"
                step="0.01"
                value="0.5"
              />

                        <h4 style="margin-top: 10px">Visualization</h4>
                        <div class="row">
                            <label>Mode</label><select id="vol-shade-select" style="width: 100%">
                  <option value="SPECULAR">Default (Specular)</option>
                  <option value="HEIGHT">Gradient</option>
                  <option value="VELOCITY">Velocity</option>
                  <option value="ENERGY">Heatmap</option>
                  <option value="DIVERGENCE">Divergence</option>
                  <option value="VECTOR_RGB">Vector RGB</option>
                </select>
                        </div>

                        <h4 style="border-bottom: none; margin-top: 5px">
                            Gradient Stops
                        </h4>
                        <div id="vol-gradient-stops"></div>

                        <label
                >Bias:
                <span id="l-vol-gb" class="value-label">0.00</span></label>
                        <input
                type="range"
                id="i-vol-gb"
                min="-1.0"
                max="1.0"
                step="0.05"
                value="0.0"
              />

                        <label
                >Contrast:
                <span id="l-vol-gc" class="value-label">1.0</span></label>
                        <input
                type="range"
                id="i-vol-gc"
                min="0.1"
                max="5.0"
                step="0.1"
                value="1.0"
              />

                        <button id="btn-add-vol-stop" style="margin-top: 4px">
                + Add Stop
              </button>
                    </div>
                </div>
            </div>

            <div id="sim-speed-group">
                <div class="expandable-header" data-target="sim-speed-content">
                    Performance<span class="expand-arrow">&#x25B8;</span>
                </div>
                <div id="sim-speed-content" class="expandable-content">
		<label>Timestep: <span id="l-dt" class="value-label">1.0</span></label>
<input type="range" id="i-dt" min="0.1" max="1.0" value="1.0" step="0.01" />
<label>Steps per Frame: <span id="l-sim-steps" class="value-label">2</span></label>
<input type="range" id="i-sim-steps" min="1" max="20" value="2" step="1" />

<label>Audio Buffer Size: <span id="l-audio-buffer" class="value-label">512</span></label>
<select id="i-audio-buffer">
    <option value="256">256</option>
    <option value="512" selected>512</option>
    <option value="1024">1024</option>
    <option value="2048">2048</option>
    <option value="4096">4096</option>
</select>
            </div>
            </div>

            <div id="presets-group">
                <div class="expandable-header" data-target="presets-content">
                    Save & Load<span class="expand-arrow">&#x25B8;</span>
                </div>
                <div id="presets-content" class="expandable-content">
                    <label style="color: #aaa; font-weight: normal"
              >Save and Load your current simulation state.</label>
                    <div class="row" style="margin-top: 5px">
                        <button id="btn-save-preset">Save Config (.txt)</button>
                        <button id="btn-load-preset">Load Config (.txt)</button>
                    </div>
                </div>
            </div>

            <div id="layers-group">
                <div class="expandable-header" data-target="layers-content">
                    Layers<span class="expand-arrow">&#x25B8;</span>
                </div>
                <div id="layers-content" class="expandable-content expanded">
                    <div class="row" style="margin-top: 5px">
                        <button id="btn-add">Add Layer</button>
                        <button id="btn-rem">Remove Layer</button>
                    </div>
                    <div id="err"></div>
                    <div id="layers"></div>
                </div>
            </div>
        </div>
        <div id="canvas-container"></div>
    </div>

    <div id="ctx-menu">
        <button id="cm-move">Move</button>
        <button id="cm-set">Settings</button>
        <button id="cm-tog">Toggle Type</button>
        <button id="cm-del" style="background: var(--color-danger)">
        Delete
      </button>
    </div>

    <div id="sdf-menu">
        <h3>Shape Builder</h3>
        <canvas id="sdf-preview" width="260" height="260"></canvas>

        <label>Shape Type</label>
        <select id="sdf-type">
        <option value="SLAB">Slab (Rectangle)</option>
        <option value="HOLLOW_BOX">Hollow Box</option>
        <option value="ELLIPSE">Elliptical Lens</option>
        <option value="PARABOLA">Parabolic Mirror</option>
        <option value="SLITS">Slit Pattern (Diffraction)</option>
      </select>

        <div id="sdf-dynamic-controls"></div>

        <h4 style="margin-top: 10px">Stamping Controls</h4>
        <label
        >Density (Refraction Index):
        <span id="l-sdf-den" class="value-label">1.00</span></label>
        <input
        type="range"
        id="i-sdf-den"
        min="0.0"
        max="1.0"
        value="1.0"
        step="0.05"
      />

        <label>Stamping Mode</label>
        <select id="sdf-mode-toggle" style="width: 100%">
  <option value="REPLACE">Replace</option>
  <option value="ADD">Add</option>
  <option value="GLOBAL">Global Density</option>
</select>

        <div class="row" style="margin-top: 8px; justify-content: flex-end">
            <button id="sdf-close">Close</button>
        </div>
    </div>

    <div id="emit-menu">
        <h3>Emitter Settings</h3>
        <div class="row" style="margin-bottom: 8px;">
            <button id="em-probe-toggle" style="width: 50%;">Make Probe</button>
            <button id="em-audio-btn" style="width: 50%;">Audio Control</button>
        </div>
        <div id="emitter-controls-group">
            <label style="margin-top: 8px;">Activation Mode</label>
            <select id="em-control-mode">
          <option value="OFF">OFF</option>
          <option value="ON">ON</option>
          <option value="KEY_ACTIVATED">Key</option>
      </select>
            <div id="em-key-select-div" style="display: none; margin-top: 4px;">
                <label>Activation Key</label>
                <input type="text" id="em-key" value="KeyQ" placeholder="Press a key to set..." style="height: auto; padding: 4px; text-align: center;">
                <label style="color: #ccc; margin-top: 4px;">State: <span id="em-state" class="value-label" style="min-width: 60px; color: #ccc;">INACTIVE</span></label>
            </div>
            <label>Geometry</label>
            <select id="em-geo">
          <option value="POINT">Point</option>
          <option value="LINE">Line</option>
        </select>
            <label>Wave Shape</label>
            <select id="em-shp">
          <option value="STATIC">Static</option>
          <option value="SINE">Sine</option>
          <option value="COSINE">Cosine</option>
          <option value="SQUARE">Square</option>
          <option value="SAW">Sawtooth</option>
          <option value="NOISE">Noise</option>
        </select>
            <label
          >Strength:
          <span id="em-st-v" class="value-label"></span
        ></label>
            <input type="range" id="em-st" min="-10" max="10" step="0.1" value="1" />
            <label>Frequency: <span id="em-rt-v" class="value-label"></span></label><input type="range" id="i-em-rt" min="1" max="400" step="1" />
            <label>Phase Offset: <span id="em-of-v" class="value-label"></span></label><input type="range" id="i-em-of" min="0" max="360" step="10" />
        </div>

        <div id="probe-controls-group"
            style="display: none; border-top: 1px solid var(--color-border); padding-top: 8px; margin-top: 8px;">
            <h4 style="margin-top: 0; border-bottom: none;">Probe Settings</h4>
            <label>Radius: <span id="pr-rad-v" class="value-label"></span></label>
            <input type="range" id="pr-rad" min="1" max="20" step="1" />
            <label>Sensitivity: <span id="pr-sens-v" class="value-label"></span></label>
            <input type="range" id="pr-sens" min="0.0" max="10.0" step="0.01" />
        </div>

        <div class="row" style="margin-top: 8px">
            <button id="em-del-btn" style="background: var(--color-danger)">
          Remove
        </button>
            <button id="em-close">Close</button>
        </div>
    </div>

    <div id="valve-menu">
        <h3>Valve Settings</h3>
        <div id="valve-controls-group">
            <label>Activation Key</label>
            <input type="text" id="v-key" value="KeyA" placeholder="Press a key to set..." style="height: auto; padding: 4px; text-align: center;">
            <label style="margin-top: 8px;">Radius: <span id="v-rad-v" class="value-label"></span></label>
            <input type="range" id="v-rad" min="1" max="30" step="1" />
            <label style="margin-top: 8px;">Closed Density: <span id="v-closed-v" class="value-label"></span></label>
            <input type="range" id="v-closed" min="0.0" max="1.0" step="0.01" />
            <label style="margin-top: 8px;">Open Density: <span id="v-open-v" class="value-label"></span></label>
            <input type="range" id="v-open" min="0.0" max="1.0" step="0.01" />
            <label style="margin-top: 8px; color: var(--color-valve-open);">State: <span id="v-state" class="value-label" style="min-width: 60px; color: var(--color-valve-open);">CLOSED</span></label>
        </div>

        <div class="row" style="margin-top: 8px">
            <button id="v-del-btn" style="background: var(--color-danger)">
              Remove
            </button>
            <button id="v-close">Close</button>
        </div>
    </div>

    <div id="probe-menu">
        <h3>Audio Control</h3>
        <canvas id="probe-graph-canvas" width="400" height="150"></canvas>
        <div id="probe-info" style="font-size: 11px; margin-bottom: 8px;"></div>
        <div class="row" style="margin-bottom: 8px;">
            <input type="checkbox" id="cb-probe-loop" style="width: auto; margin: 0" />
            <label for="cb-probe-loop" style="margin-left: 4px; color: #fff; width: auto;">Loop</label>
            <button id="probe-save-wav" style="width: 50%; margin-left: auto;">Save WAV</button>
        </div>
        <label style="width: 100%; margin-bottom: 4px;">Sample Range (<span id="l-sample-range" class="value-label" style="min-width: 150px;">0 - 500</span>)</label>
        <div class="row">
            <input type="range" id="probe-start-marker" min="0" max="500" value="0" step="1" class="custom-drag-slider marker-slider" style="width: 50%;">
            <input type="range" id="probe-end-marker" min="0" max="500" value="500" step="1" class="custom-drag-slider marker-slider" style="width: 50%;">
        </div>
        <div class="row" style="margin-top: 8px;">
            <label style="width: 50%;">History Frames: <span id="probe-hist-v" class="value-label">500</span></label>
            <input type="range" id="probe-hist-len" min="100" max="50000" step="100" value="500" style="width: 50%;" />
        </div>
        <div class="row" style="margin-bottom: 8px;">
            <label style="width: 50%;">Sample Rate: <span id="probe-sr-v" class="value-label">22050</span></label>
            <input type="range" id="probe-sample-rate" min="4000" max="44100" step="4410" value="22050" style="width: 50%;" />
        </div>

        <div class="row" style="margin-bottom: 8px;">
            <button id="probe-play-btn" style="width: 50%; background: #28a745;">Play Clip</button>
            <button id="probe-live-btn" style="width: 50%; background: #4a7a9c;">Live Mode</button>
        </div>
        <button id="probe-close-btn" style="width: 100%;">Close</button>
    </div>

    <script>
        var IS_ALPHA_MODULATION = true;
      var EXPOSURE = 1.0;
      var AUTO_EXPOSURE = false;
      var MAX_WAVE_ABS = 0.0;
      var $ = (id) => document.getElementById(id);
      var EV = (id, t, fn) => {
        const el = $(id);
        if (el) el.addEventListener(t, fn);
      };

      var GRID = 80,
        GAP = 15,
        ZSC = 2.0,
        TIME = 0;
      var scene, camera, renderer, raycaster, canvasContainer;
      var IS_3D_MODE = false;
      var VOL_LAYERS = 40;
      var IS_PAUSED = false;
      var layers = [],
        u = [],
        u_prev = [],
        u_aux = [],
        den = [],
        layerCouplingContributions = [],
        layerDensityModulations = [],
        meshes = [],
        emitMeshes = [],
        obsMeshes = [];
      var emits = [],
        shapes = [],
        VALVES = [], 
        brush = "DISTURBANCE";
      var mRad = 10,
        mVal = 0.5,
        sunDir = new THREE.Vector3(),
        lInt = 1.0;
      // Add these global variables near your other drag variables (mX, mY, isDrag, etc.)
var dragStartLayerIdx = -1;
var dragMode = null; // 'LATERAL', 'VERTICAL'
var isVerticalDrag = false;
			var isOrbit = false,
        isDrag = false,
        actEmit = null,
        mX = 0,
        mY = 0,
        rad = 60,
        theta = 45,
        phi = 60;
      var sdfCoords = null,
        editEmitId = null,
        editValveId = null,
        actEmitPart = "BODY";
      var TGT = new THREE.Vector3(0, 0, 0);
      var brushHnd = 0.0;
      var DT_FACTOR = 1.0;
      var VISCOSITY = 0.0;
      var layerCounter = 0;
      var visMin = 0.0,
        visMax = 1.0;
      var cubeRenderTarget = null;
      var IS_VOL_ABSORBING_BND = false;
      var PROBE_HISTORY = [];
      var PROBE_HISTORY_LENGTH = 6000;
      var MAX_HISTORY_LENGTH = 48000;
      var PROBE_SAMPLE_RATE = 11025;
      var PROBE_TIME_STEP_COUNTER = 0;
      var AUDIO_CONTEXT = null;
      var ACTIVE_PROBE_ID = null;
      var ACTIVE_PROBE_SOURCE = null;
      var IS_AUDIO_PLAYING = false;

      var IS_LOOPING = false;
      var LOOP_START_IDX = 0;
      var LOOP_END_IDX = 6000;
      var LOOP_FADE_SAMPLES = 512;

      var IS_REALTIME_AUDIO = false;
      var REALTIME_PROCESSOR = null; 
      var REALTIME_GAIN = null;
      var SIM_SAMPLES_PER_AUDIO_BUFFER = 512;
      var SIM_STEPS_PER_FRAME = 2;

      var IMPULSE_MAGNITUDE = 5.0;
      var IS_IMPULSE_HOLD = false;
      var IMPULSE_SHAPE = "GAUSSIAN";
      var IMPULSE_WAVE_TYPE = "CONSTANT";
      var IMPULSE_WAVELENGTH = 20;

			var layerCouplingContributions = []; 
			var layerDensityModulations = [];
			var meshes = [];


      var dragStartGridCoords = { i: 0, j: 0, i2: 0, j2: 0 };
      var isContinuousBrushActive = false;
      var pulseStartTime = 0;
      var activeBrushHit = null;

      var DEN_FLOW_RATE = 0.1;
      var DEN_BRUSH_MODE = "REPLACE";
      var GLOBAL_DEN = new Float32Array(GRID * GRID);
      var GLOBAL_DEN_ABSORPTION = 0.0;
      var GLOBAL_DEN_REFRACTION = 1.0;
      var sdfPlacementGrid = { i: 40, j: 40, lIdx: 0 };
      var GLOBAL_COUPLING_LINKS = [];
      var SDF_STAMP_MODE = "REPLACE";

      var dragPlane = new THREE.Plane();
      var dragStartOffset = new THREE.Vector3();

      const MAX_GRADIENT_STOPS = 8;
      var currentSDFParams = {
        type: "SLAB",
        density: 1.0,
        width: 40,
        height: 20,
        thickness: 5,
        radiusX: 30,
        radiusY: 15,
        focalLength: 10,
        slitCount: 2,
        slitWidth: 4,
        spacing: 10,
      };

      const DEFAULT_GRADIENT_STOPS = [
        [64, 128, 196],
        [255, 255, 255],
      ];
      const DEFAULT_VOL_GRADIENT_STOPS = [
        [64, 128, 255],
        [255, 255, 255],
      ];

      const BASE_POINT_SETTINGS = {
        pointSize: 1.0,
        pointScaleFactor: 2.0,
        pointFalloff: 0.0,
      };

      const FORMULA_PRESETS = {
        WAVE: {
          name: "Standard Wave Equation",
          defaultC: 0.25,
          defaultD: 0.0,
          C_label: "Wave Speed (C)",
          D_label: "Damping (D)",
          C_max: 0.5,
          D_max: 0.1,
        },
        DIFFUSION: {
          name: "Simple Diffusion",
          defaultC: 0.2,
          defaultD: 0.001,
          C_label: "Diffusion Rate (C)",
          D_label: "Decay Rate (D)",
          C_max: 0.5,
          D_max: 0.01,
        },
        REACTION: {
          name: "Reaction-Diffusion (Single Component)",
          defaultC: 0.16,
          defaultD: 0.062,
          C_label: "Feed Rate (F)",
          D_label: "Kill Rate (k)",
          C_max: 0.3,
          D_max: 0.1,
        },
        CUSTOM: {
          name: "Custom Model",
          defaultC: 0.25,
          defaultD: 0.005,
          C_label: "Base C",
          D_label: "Base D",
          C_max: 0.5,
          D_max: 0.1,
        },
      };
const WORLD_SIZE_METERS = 10.0;
const GRID_STEP_METERS = WORLD_SIZE_METERS / (GRID > 1 ? GRID - 1 : 1);
const BASE_WAVE_SPEED_M_S = 343.0;
const SIM_SPEED_MAX_M_S = 343.0;
      const COUPLING_TYPES = {
        ENERGY_EXCHANGE: "Symmetric Energy Exchange",
        MODULATE_DENSITY: "Modulate Target Density",
        APPLY_FORCE: "Apply Velocity Force",
      };
      
      const BASE_PROBE_CFG = {
          isProbe: false,
          probeRadius: 3,
          probeSensitivity: 1.0,
      };
      
const BASE_EMITTER_CFG = {
    isProbe: false,
    probeRadius: 3,
    probeSensitivity: 1.0,
    controlMode: "OFF",
    key: "KeyQ",
    isKeyPressed: false,
    
    // NEW/REFACTORED:
    repeatMode: "CONTINUOUS", // "CONTINUOUS", "PULSE", "REPEAT"
    repeatIntervalSeconds: 0.5, // Used only if repeatMode is "REPEAT"
    lastPulseTime: 0,
    isPulsing: false,
};


      const BASE_VALVE_CFG = {
          id: 0,
          i: 40,
          j: 40,
          lIdx: 0,
          radius: 10,
          key: "KeyA",
          openDensity: 0.0,
          closedDensity: 1.0,
          isKeyPressed: false,
      };

      const BASE_LAYER_CFG = {
        C: FORMULA_PRESETS.WAVE.defaultC,
        D: FORMULA_PRESETS.WAVE.defaultD,
        K: 0.0,
        vis: true,
        intr: true,
        bnd: "FIXED",
        visMode: "MESH",
        shadingMode: "DIVERGENCE",
        formulaKey: "WAVE",
        gradientBias: 0.0,
        gradientContrast: 1.0,
        gradientStops: DEFAULT_GRADIENT_STOPS,
        volShadingMode: "DIVERGENCE",
        volGradientStops: DEFAULT_VOL_GRADIENT_STOPS,
        volGradientBias: 0.0,
        volGradientContrast: 1.0,
        pointSize: BASE_POINT_SETTINGS.pointSize,
        pointScaleFactor: BASE_POINT_SETTINGS.pointScaleFactor,
        pointFalloff: BASE_POINT_SETTINGS.pointFalloff,
      };

      const DEFAULT_CUSTOM_FORMULA = {
        name: "Non-Linear Wave Equation",
        variables: "G=0.01;",
        code: "2*U_CURR - U_PREV + C_final*LAP*DT_FACTOR*DT_FACTOR - D_final*(U_CURR - U_PREV) + G*U_CURR*U_CURR*U_CURR + COUPLING_TERM + EXT_COUPLING",
      };

      var GLOBAL_CUSTOM_FORMULA = { ...DEFAULT_CUSTOM_FORMULA };
      var COMPILED_CUSTOM_FUNCTION = null;
      var FORMULA_ERROR = null;

      var REFLECTIVITY = 0.8;

      const DEFAULT_STATE_CONFIG = {
        global: {
          GRID: 80,
          GAP: 15,
          ZSC: 2.0,
          DT_FACTOR: 1.0,
          VISCOSITY: 0.0,
          lInt: 1.0,
          REFLECTIVITY: 0.5,
          visMin: 0.0,
          visMax: 1.0,
          IS_3D_MODE: false,
          VOL_LAYERS: 80,
          sunPitch: 45,
          sunYaw: 45,
          GLOBAL_DEN_ABSORPTION: 0.0,
          GLOBAL_DEN_REFRACTION: 1.0,
          EXPOSURE: 1.0,
          AUTO_EXPOSURE: false,
        },
        layers: [
          {
            ...BASE_LAYER_CFG,
            name: "Layer 1",
            visMode: "MESH",
            shadingMode: "SPECULAR",
            C: 0.25,
            D: 0.0,
            intr: true,
          },
        ],
        emits: [],
        valves: [],
        camera: { rad: 60, theta: 45, phi: 60 },
        globalDen: Array.from(new Float32Array(80 * 80).fill(0)),
        globalCoupling: [],
        customFormula: { ...DEFAULT_CUSTOM_FORMULA },
      };

      var PRESETS = { DEFAULT_WAVE: DEFAULT_STATE_CONFIG };
      var SHOW_DENSITY = true;
      var SHOW_VOL_WIREFRAME = false;
      var volumeBoxMesh = null;
      
      function setupAudio() {
          if (AUDIO_CONTEXT && AUDIO_CONTEXT.sampleRate !== PROBE_SAMPLE_RATE) {
              AUDIO_CONTEXT.close().then(() => {
                  AUDIO_CONTEXT = null;
                  setupAudio();
              }).catch(e => {
                  console.error("Failed to close old audio context.", e);
              });
              return;
          }

          if (!AUDIO_CONTEXT) {
              try {
                  AUDIO_CONTEXT = new (window.AudioContext || window.webkitAudioContext)({
                      sampleRate: PROBE_SAMPLE_RATE 
                  });
              } catch(e) {
                  console.error("Web Audio API is not supported in this browser.", e);
              }
          }
      }

      function createWAVBlob(audioData, sampleRate) {
          const dataView = new DataView(new ArrayBuffer(44 + audioData.length * 2));
          const sampleCount = audioData.length;
          const channelCount = 1;
          const bytesPerSample = 2;

          dataView.setUint32(0, 0x52494646, false);
          dataView.setUint32(4, 36 + sampleCount * bytesPerSample, true);
          dataView.setUint32(8, 0x57415645, false);
          dataView.setUint32(12, 0x666d7420, false);
          dataView.setUint32(16, 16, true);
          dataView.setUint16(20, 1, true);
          dataView.setUint16(22, channelCount, true);
          dataView.setUint32(24, sampleRate, true);
          dataView.setUint32(28, sampleRate * channelCount * bytesPerSample, true);
          dataView.setUint16(32, channelCount * bytesPerSample, true);
          dataView.setUint16(34, 16, true);
          dataView.setUint32(36, 0x64617461, false);
          dataView.setUint32(40, sampleCount * bytesPerSample, true);

          const audioDataView = new Int16Array(dataView.buffer, 44);
          for (let i = 0; i < sampleCount; i++) {
              let sample = Math.max(-1, Math.min(1, audioData[i]));
              audioDataView[i] = sample * 0x7FFF;
          }

          return new Blob([dataView.buffer], { type: 'audio/wav' });
      }

      function saveWavFile(data, sampleRate, maxAmplitude) {
          if (data.length === 0) {
              console.error("No data to save.");
              return;
          }
          const start = IS_LOOPING ? 0 : LOOP_START_IDX; 
          const end = IS_LOOPING ? data.length : Math.min(LOOP_END_IDX, data.length);
          const clipData = data.slice(start, end);

          const maxVal = clipData.reduce((max, val) => Math.max(max, Math.abs(val)), 0);
          const scaleFactor = 1.0 / Math.max(0.01, maxVal);
          const normalizedData = clipData.map(val => val * scaleFactor * 0.9);

          const blob = createWAVBlob(normalizedData, sampleRate);
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = 'probe_signal.wav';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
      }
      
      function applyCrossFade(data, startIdx, endIdx, fadeSamples) {
          if (startIdx >= endIdx || !IS_LOOPING || data.length === 0) {
              return data.slice(startIdx, endIdx);
          }
          
          const N = data.length;
          const clip = data.slice(startIdx, endIdx);

          if (IS_LOOPING) {
             const fadeLength = Math.min(fadeSamples, Math.floor(N / 4));
             if (fadeLength > 0) {
                const clipLength = clip.length;
                for (let i = 0; i < fadeLength; i++) {
                    const indexA = clipLength - fadeLength + i;
                    const indexB = i;
                    
                    const fadeOut = (fadeLength - i) / fadeLength;
                    const fadeIn = i / fadeLength;
                    
                    clip[indexA] = (clip[indexA] * fadeOut) + (clip[indexB] * fadeIn);
                }
             }
          }
          return clip;
      }

      function resetAudioPlaybackState() {
          IS_AUDIO_PLAYING = false;
          const playBtn = $('probe-play-btn');
          if (playBtn) {
              playBtn.textContent = 'Play Clip';
              playBtn.style.background = '#28a745';
              playBtn.disabled = false;
          }
      }

      function stopRealtimeAudio() {
          if (REALTIME_PROCESSOR) {
              try {
                   IS_REALTIME_AUDIO = false; 
                   
                   if (REALTIME_GAIN && AUDIO_CONTEXT) {
                       REALTIME_GAIN.gain.setValueAtTime(REALTIME_GAIN.gain.value, AUDIO_CONTEXT.currentTime);
                       REALTIME_GAIN.gain.exponentialRampToValueAtTime(0.0001, AUDIO_CONTEXT.currentTime + 0.05); 
                   }

                   setTimeout(() => {
                      if (REALTIME_PROCESSOR) {
                          REALTIME_PROCESSOR.disconnect();
                          REALTIME_PROCESSOR = null;
                      }
                      REALTIME_GAIN = null;
                   }, 50);

              } catch (e) {
                  console.warn("Error disconnecting Realtime Processor:", e);
              }
          }
          
          IS_REALTIME_AUDIO = false;
          const liveBtn = $('probe-live-btn');
          if (liveBtn) {
              liveBtn.textContent = 'Start Live Mode';
              liveBtn.style.background = '#4a7a9c';
          }
      }

      function stopAudio() {
          if (ACTIVE_PROBE_SOURCE) {
              try {
                  ACTIVE_PROBE_SOURCE.stop(0);
              } catch (e) {
                  console.warn("Error stopping audio source:", e);
              }
              ACTIVE_PROBE_SOURCE = null;
          }
          resetAudioPlaybackState();
          
          stopRealtimeAudio(); 
      }

      function playAudio(data, sampleRate, maxAmplitude) {
          if (!AUDIO_CONTEXT) {
              setupAudio();
              if (!AUDIO_CONTEXT) return;
          }
          
          stopAudio();

          if (AUDIO_CONTEXT.state === 'suspended') {
              AUDIO_CONTEXT.resume().catch(e => {
                  console.error("Failed to resume AudioContext:", e);
                  stopAudio();
                  return;
              });
          }

          const start = IS_LOOPING ? 0 : LOOP_START_IDX;
          const end = IS_LOOPING ? data.length : Math.min(LOOP_END_IDX, data.length);

          const maxVal = data.slice(start, end).reduce((max, val) => Math.max(max, Math.abs(val)), 0);
          
          const scaleFactor = 1.0 / Math.max(0.01, maxVal);
          const normalizedData = data.map(val => val * scaleFactor * 0.9);

          let playbackData;
          if (IS_LOOPING) {
              playbackData = normalizedData;
          } else {
              playbackData = normalizedData.slice(start, end);
          }

          const bufferSize = playbackData.length;
          if (bufferSize === 0) {
              console.warn("Playback range is empty. Cannot play.");
              return;
          }

          const buffer = AUDIO_CONTEXT.createBuffer(1, bufferSize, sampleRate);
          buffer.getChannelData(0).set(playbackData);
          
          const source = AUDIO_CONTEXT.createBufferSource();
          source.buffer = buffer;
          source.connect(AUDIO_CONTEXT.destination);
          
          source.loop = IS_LOOPING;

          source.start();
          
          ACTIVE_PROBE_SOURCE = source;
          IS_AUDIO_PLAYING = true;

          const playBtn = $('probe-play-btn');
          playBtn.textContent = 'Playing... (Click to Stop)';
          playBtn.style.background = 'var(--color-warning)';
          playBtn.disabled = false;

          source.onended = () => {
              if (ACTIVE_PROBE_SOURCE === source) {
                  stopAudio(); 
              }
          };
          
          source.onerror = (e) => {
              console.error("Audio playback error:", e);
              stopAudio();
          };
      }
      const SIM_SAMPLES_PER_STEP = 1;
function connectLiveAudio() {
    if (!AUDIO_CONTEXT) {
        setupAudio();
        if (!AUDIO_CONTEXT) return;
    }

    REALTIME_PROCESSOR = AUDIO_CONTEXT.createScriptProcessor(SIM_SAMPLES_PER_AUDIO_BUFFER, 0, 1);
    REALTIME_GAIN = AUDIO_CONTEXT.createGain();

    REALTIME_GAIN.gain.setValueAtTime(0.0, AUDIO_CONTEXT.currentTime);
    
    REALTIME_PROCESSOR.onaudioprocess = function(e) {
        if (!IS_REALTIME_AUDIO || IS_PAUSED || !ACTIVE_PROBE_ID || !REALTIME_GAIN) {
            e.outputBuffer.getChannelData(0).fill(0);
            return;
        }

        const outputBuffer = e.outputBuffer.getChannelData(0);
        const bufferSize = outputBuffer.length;
        
        const em = emits.find((x) => x.id === ACTIVE_PROBE_ID);
        const sensitivity = em ? em.probeSensitivity : 0.5;
        const TARGET_GAIN = 0.5 * sensitivity;

        for (let i = 0; i < bufferSize; i++) {
            sim(); 

            let liveSample = PROBE_HISTORY.length > 0 
                ? PROBE_HISTORY[PROBE_HISTORY.length - 1] 
                : 0;

            let scaledSample = liveSample;
            scaledSample = Math.tanh(scaledSample * 2.0) / 2.0;

            outputBuffer[i] = scaledSample; 
        }

        REALTIME_GAIN.gain.exponentialRampToValueAtTime(TARGET_GAIN, AUDIO_CONTEXT.currentTime + 0.1); 
    };
    
    REALTIME_PROCESSOR.connect(REALTIME_GAIN);
    REALTIME_GAIN.connect(AUDIO_CONTEXT.destination);
}
function startRealtimeAudio() {
    if (!AUDIO_CONTEXT) {
        setupAudio();
        if (!AUDIO_CONTEXT) return;
    }
    
    if (AUDIO_CONTEXT.state === 'suspended') {
        AUDIO_CONTEXT.resume().catch(e => {
            return;
        });
    }

    stopAudio(); 
    stopRealtimeAudio(); 
    
    if (!ACTIVE_PROBE_ID) {
        return;
    }

    connectLiveAudio();
    IS_REALTIME_AUDIO = true;

    const liveBtn = $('probe-live-btn');
    liveBtn.textContent = 'Stop';
    liveBtn.style.background = 'var(--color-danger)';
}

      function renderProbeGraph(history, maxVal) {
          const canvas = $('probe-graph-canvas');
          if (!canvas) return;
          const ctx = canvas.getContext('2d');
          const W = canvas.width;
          const H = canvas.height;

          ctx.fillStyle = '#111';
          ctx.fillRect(0, 0, W, H);
          
          ctx.strokeStyle = '#333';
          ctx.beginPath();
          ctx.moveTo(0, H / 2);
          ctx.lineTo(W, H / 2);
          ctx.stroke();

          if (history.length === 0) return;

          const maxAbs = Math.max(0.01, maxVal);
          const L_visible = history.length;

          ctx.strokeStyle = varToRgba('--color-probe', 1.0);
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          
          history.forEach((value, index) => {
              const x = (index / L_visible) * W;
              const normalizedValue = value / maxAbs; 
              const y = H / 2 - (normalizedValue * H / 2) * 0.9; 
              
              if (index === 0) {
                  ctx.moveTo(x, y);
              } else {
                  ctx.lineTo(x, y);
              }
          });
          
          ctx.stroke();
          
          ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
          ctx.font = '10px Inter';
          ctx.fillText('+' + maxAbs.toFixed(2), 5, 10);
          ctx.fillText('-' + maxAbs.toFixed(2), 5, H - 2);

          ctx.strokeStyle = 'rgba(255, 255, 0, 0.9)'; 
          ctx.lineWidth = 1.5;
          const startX = (LOOP_START_IDX / L_visible) * W;
          ctx.beginPath();
          ctx.moveTo(startX, 0);
          ctx.lineTo(startX, H);
          ctx.stroke();

          ctx.strokeStyle = 'rgba(255, 0, 255, 0.9)';
          const endX = (LOOP_END_IDX / L_visible) * W;
          ctx.beginPath();
          ctx.moveTo(endX, 0);
          ctx.lineTo(endX, H);
          ctx.stroke();
      }
      
      function varToRgba(cssVar, alpha) {
          const color = getComputedStyle(document.documentElement).getPropertyValue(cssVar).trim();
          if (color.startsWith('#')) {
              let r = parseInt(color.slice(1, 3), 16);
              let g = parseInt(color.slice(3, 5), 16);
              let b = parseInt(color.slice(5, 7), 16);
              return `rgba(${r}, ${g}, ${b}, ${alpha})`;
          }
          return `rgba(229, 104, 178, ${alpha})`;
      }

      function disposeMesh(mesh) {
        if (mesh) {
          if (mesh.geometry) mesh.geometry.dispose();
          if (mesh.material) {
            if (Array.isArray(mesh.material)) {
              mesh.material.forEach((m) => m.dispose());
            } else {
              mesh.material.dispose();
            }
          }
          scene.remove(mesh);
        }
      }

      function updateVolumeBox() {
        if (volumeBoxMesh) {
          disposeMesh(volumeBoxMesh);
          volumeBoxMesh = null;
        }

        if (!IS_3D_MODE || !SHOW_VOL_WIREFRAME) return;

        const gridStep = 50.0 / (GRID > 1 ? GRID - 1 : 1);

        const width = 50;
        const depth = 50;
        const totalHeight = (layers.length - 1) * gridStep;

        const geometry = new THREE.BoxGeometry(width, totalHeight, depth);
        const edges = new THREE.EdgesGeometry(geometry);

        volumeBoxMesh = new THREE.LineSegments(
          edges,
          new THREE.LineBasicMaterial({
            color: 0x44aaff,
            opacity: 0.3,
            transparent: true,
          }),
        );
        volumeBoxMesh.position.set(0, 0, 0);
        scene.add(volumeBoxMesh);
      }

      function createBlackCubemap() {
        const size = 1;
        const data = new Uint8Array([0, 0, 0]);
        const texture = new THREE.DataTexture(
          data,
          size,
          size,
          THREE.RGBFormat,
        );
        texture.needsUpdate = true;

        const textures = [];
        for (let i = 0; i < 6; i++) {
          textures.push(texture.image);
        }

        return new THREE.CubeTexture(textures, THREE.CubeReflectionMapping);
      }

      function loadSkybox() {
        const loader = new THREE.CubeTextureLoader();

        const filePaths = [
          "skybox.png",
          "skybox.png",
          "skybox.png",
          "skybox.png",
          "skybox.png",
          "skybox.png",
        ];

        loader.load(
          filePaths,
          (texture) => {
            texture.mapping = THREE.CubeReflectionMapping;
            cubeRenderTarget = texture;
            scene.background = cubeRenderTarget;
            scene.environment = cubeRenderTarget;
            syncM();
          },
          undefined,
          (err) => {
            console.warn("Could not load skybox. Using black cubemap.", err);
            cubeRenderTarget = createBlackCubemap();
            scene.background = new THREE.Color(0x000000);
            scene.environment = cubeRenderTarget;
            syncM();
          },
        );
      }

const GLSL_COMMON_FUNCTIONS = `
uniform vec3 SUN_DIR;
uniform float LIGHT_INTENSITY;
uniform float REFLECTIVITY;
uniform samplerCube tCube;
uniform int SHADING_MODE;
uniform float GRADIENT_BIAS;
uniform float GRADIENT_CONTRAST;
uniform vec3 GRADIENT_STOPS[8];
uniform int GRADIENT_STOPS_COUNT;
uniform float VIS_MIN;
uniform float VIS_MAX;
uniform float uOpacity;
uniform float uShowDensity;
uniform float uExposure;
uniform float uValveDensityBlend; // NEW: Uniform for valve density visualization

varying vec3 vNormal;
varying vec3 vViewDir;
varying float vWaveHeight;
varying float vWaveVelocity;
varying float vDensity;

vec3 spectral_phase(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.0, 0.333, 0.667);
    return a + b * cos(6.28318 * (c * t + d));
}

vec3 heatmap(float value) {
    value = clamp(value, 0.0, 1.0);
    if (value < 0.3) return mix(vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0), value / 0.3);
    if (value < 0.7) return mix(vec3(0.0, 1.0, 0.0), vec3(1.0, 1.0, 0.0), (value - 0.3) / 0.4);
    return mix(vec3(1.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), (value - 0.7) / 0.3);
}

vec3 apply_gradient(float data_val) {
    float shifted = clamp(data_val * GRADIENT_CONTRAST + GRADIENT_BIAS, 0.0, 1.0);
    if (GRADIENT_STOPS_COUNT <= 1) return GRADIENT_STOPS[0];
    float idx_f = shifted * float(GRADIENT_STOPS_COUNT - 1);
    int idx_l = int(floor(idx_f)); int idx_h = int(ceil(idx_f));
    return mix(GRADIENT_STOPS[idx_l], GRADIENT_STOPS[idx_h], fract(idx_f));
}

float fresnel(vec3 N, vec3 V, float IoR) {
    float cosTheta = clamp(dot(N, V), 0.0, 1.0);
    float R0 = pow((1.0 - IoR) / (1.0 + IoR), 2.0);
    return R0 + (1.0 - R0) * pow(1.0 - cosTheta, 5.0);
}

vec4 calculateColor(bool isPoints, float pointFalloff, bool modulateAlpha) {
    float raw = 0.0;
    float energyEnvelope = 0.0;
    
    if (SHADING_MODE == 1) raw = abs(vWaveHeight) * 0.2; 
    else if (SHADING_MODE == 2) raw = (vWaveVelocity * 2.0 / (1.0 + abs(vWaveVelocity * 2.0))) * 0.5 + 0.5;
    else if (SHADING_MODE == 3) raw = vWaveHeight * vWaveHeight * 0.02; 
    else raw = abs(vWaveHeight) * 0.2; 

    float clipVal = (SHADING_MODE == 2) ? abs(raw - 0.5) * 2.0 : raw;
    if (clipVal < VIS_MIN || (clipVal > VIS_MAX && clipVal <= 1.0)) return vec4(0.0);

    vec3 col;
    
    if (SHADING_MODE == 0) { 
        vec3 N = normalize(vNormal);
        vec3 V = normalize(vViewDir);
        vec3 L = SUN_DIR; 
        
        vec3 baseColor = GRADIENT_STOPS[0];
        float IoR = 1.33;
        
        float NdotL = max(0.0, dot(N, L));
        
        vec3 waterBase = baseColor * 0.7 + vec3(0.0); 
        vec3 diffuse = waterBase * (vec3(0.4) + NdotL * LIGHT_INTENSITY * 0.8);

        vec3 H = normalize(L + V);
        float NdotH = max(0.0, dot(N, H));
        
        float shininess = 5.0 + REFLECTIVITY * 145.0; 
        float specular = pow(NdotH, shininess) * LIGHT_INTENSITY * REFLECTIVITY; 
        vec3 specularColor = vec3(1.0); 

        float F = fresnel(N, V, IoR);
        
        vec3 R = reflect(-V, N);
        vec3 reflection = textureCube(tCube, R).rgb * REFLECTIVITY;
        
        vec3 baseLight = diffuse + specularColor * specular;
        col = mix(baseLight, reflection, F);
		col = mix(col, reflection, REFLECTIVITY);
        col *= (1.0 - F * 0.1); 

    } 
    else if (SHADING_MODE == 4) { 
        float v = clamp(vWaveHeight * 0.5, -1.0, 1.0);
        if (v < 0.0) col = mix(vec3(0.05), vec3(0.2, 0.5, 1.0), -v);
        else col = mix(vec3(0.05), vec3(1.0, 0.3, 0.2), v);
    } 
    else if (SHADING_MODE == 5) { 
        float h = vWaveHeight * 0.5; 
        float v = vWaveVelocity * 8.0; 
        energyEnvelope = sqrt(h*h + v*v);
        float angle = atan(v, h); 
        float phase = angle / 6.28318 + 0.5; 
        vec3 spectralColor = spectral_phase(phase);
        float brightness = smoothstep(0.0, 1.0, sqrt(energyEnvelope) * 1.5);
        col = spectralColor * brightness;
        col += vec3(smoothstep(1.0, 3.0, energyEnvelope) * 0.5);
    } 
    else { 
        vec3 map = (SHADING_MODE == 3) ? heatmap(clamp(raw,0.,1.)) : apply_gradient(raw);
        float d = max(0.0, dot(vNormal, SUN_DIR));
        col = map * (vec3(0.4) + d * LIGHT_INTENSITY * 0.8);
    }
    
    // NEW/FIXED: Valve Density Visualization
    if (uShowDensity > 0.5 && vDensity > 0.01) {
        // Orange for Valve Density
        vec3 valveColor = vec3(1.0, 0.45, 0.0); 
        // Cyan/Blue for Persistent/Global Density
        vec3 densityColor = vec3(0.6, 0.9, 1.0); 
        
        // Check the blend uniform set in the JS loop for this specific point
        vec3 targetColor = mix(densityColor, valveColor, uValveDensityBlend);
        
        // Blend between the calculated wave color (col) and the density color (targetColor)
        // using the density value (vDensity) for opacity/mix factor.
        col = mix(col, targetColor, vDensity * 0.5); 
        col += targetColor * vDensity * 0.2; 
    }
    
    float finalAlpha = uOpacity;

    if (modulateAlpha && isPoints) {
        float magnitude = 0.0;
        if (SHADING_MODE == 5) magnitude = energyEnvelope;
        else if (SHADING_MODE == 2) magnitude = abs(vWaveVelocity) * 4.0; 
        else magnitude = abs(vWaveHeight) * 0.5;
        
        float signalAlpha = smoothstep(0.005, 0.15, magnitude);
        
        if (uShowDensity > 0.5) {
            signalAlpha = max(signalAlpha, vDensity); 
        }

        finalAlpha *= signalAlpha;
    }
    
    col *= uExposure;
    
    return vec4(col, finalAlpha);
}
`;

      const GLSL_MESH_VS = `
uniform float uZScale;

attribute float waveHeight;
attribute float waveVelocity;
attribute float aDensity; 

varying vec3 vNormal;
varying vec3 vViewDir;
varying float vWaveHeight;
varying float vWaveVelocity;
varying float vDensity;

void main() { 
    vec3 newPosition = position;
    newPosition.y += waveHeight * 2.0 * uZScale * 0.05; 
    
    vec4 worldPosition = modelMatrix * vec4(newPosition, 1.0);

    vNormal = normalize(mat3(modelMatrix) * normal); 
    vWaveHeight = waveHeight; 
    vWaveVelocity = waveVelocity; 
    vDensity = aDensity; 
    
    vViewDir = normalize(cameraPosition - worldPosition.xyz);

    gl_Position = projectionMatrix * viewMatrix * worldPosition;
}
`;

      const GLSL_MESH_FS =
        GLSL_COMMON_FUNCTIONS +
        `
uniform float uAlphaTest;
void main() {
    vec4 c = calculateColor(false, 0.0, false);
    if (c.a < uAlphaTest) discard;
    gl_FragColor = c;
}
`;

      const GLSL_POINTS_VS = `
uniform float uPointSize; 
uniform float uPointScaleFactor;
uniform bool uIs3DPoints;

attribute float waveHeight;
attribute float waveVelocity;
attribute float aDensity; 

varying vec3 vNormal;
varying vec3 vViewDir;
varying float vWaveHeight;
varying float vWaveVelocity;
varying float vDensity;

void main() { 
    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
    
    if (!uIs3DPoints) { 
        worldPosition.y += waveHeight * 2.0 * 0.05; 
    }

    vNormal = normalize(mat3(modelMatrix) * normal); 
    vWaveHeight = waveHeight; 
    vWaveVelocity = waveVelocity; 
    vDensity = aDensity; 
    
    vViewDir = normalize(cameraPosition - worldPosition.xyz);

    vec4 mvPosition = viewMatrix * worldPosition;
    gl_Position = projectionMatrix * mvPosition;
    
    float amp = smoothstep(0.0, 1.0, abs(waveHeight));
    gl_PointSize = uPointSize * (1.0 + amp * uPointScaleFactor); 
    gl_PointSize *= (300.0 / -mvPosition.z); 
}
`;

      const GLSL_POINTS_FS =
        GLSL_COMMON_FUNCTIONS +
        `
uniform float uAlphaTest;
uniform float uPointFalloff;
uniform bool uModulateAlpha;

void main() {
    vec4 c = calculateColor(true, uPointFalloff, uModulateAlpha);
    
    vec2 coord = gl_PointCoord - vec2(0.5);
    float r = length(coord) * 2.0;
    
    if (r > 1.0) discard;
    float sharpness = (uPointFalloff * 10.0);
    float g = exp(-(r * r) * sharpness);
    
    c.a *= g;
    
    if (c.a < uAlphaTest) discard;
    
    gl_FragColor = c;
}
`;

      var selectedEmitterId = null;
      var selectedValveId = null;
      var stampPreviewMesh = null;

      var rgbToNormVec = (rgb) => [
        rgb[0] / 255.0,
        rgb[1] / 255.0,
        rgb[2] / 255.0,
      ];
      var toHex = (c) =>
        `#${((c[0] << 16) | (c[1] << 8) | c[2]).toString(16).padStart(6, "0")}`;
      var hexToRgb = (hex) => [
        parseInt(hex.slice(1, 3), 16),
        parseInt(hex.slice(3, 5), 16),
        parseInt(hex.slice(5, 7), 16),
      ];
      var uniformsArray = (colors) => {
        var arr = [];
        for (var c of colors) arr.push(c);
        return arr;
      };
      var nm = (e) => {
        if (!canvasContainer) return new THREE.Vector2(0, 0);
        var r = canvasContainer.getBoundingClientRect();
        return new THREE.Vector2(
          ((e.clientX - r.left) / r.width) * 2 - 1,
          -((e.clientY - r.top) / r.height) * 2 + 1,
        );
      };

      function getLayerSpacing() {
        const gridStep = 50.0 / (GRID > 1 ? GRID - 1 : 1);
        return IS_3D_MODE ? gridStep : GAP * 0.1;
      }

      function getWorldToGridScale() {
        const layerSpacing = getLayerSpacing();
        return {
          x: (GRID - 1) / 50.0,
          z: (GRID - 1) / 50.0,
          y: 1.0 / layerSpacing,
        };
      }

      var gtw = (i, j, l) => {
        const layerSpacing = getLayerSpacing();

        const totalHeight = (layers.length - 1) * layerSpacing;
        const centerYOffset = IS_3D_MODE ? totalHeight / 2 : 0;

        const yPos = centerYOffset - l * layerSpacing;

        return new THREE.Vector3(
          (j / (GRID - 1)) * 50 - 25,
          yPos,
          (i / (GRID - 1)) * 50 - 25,
        );
      };

      var wtg = (x, z) => ({
        i: Math.min(GRID - 1, Math.max(0, ((z + 25) / 50) * GRID) | 0),
        j: Math.min(GRID - 1, Math.max(0, ((x + 25) / 50) * GRID) | 0),
      });
      var sampleGrid = (arr, oldGrid, r, c) => {
        var i = r * (oldGrid - 1),
          j = c * (oldGrid - 1);
        var i0 = Math.floor(i),
          i1 = Math.min(oldGrid - 1, i0 + 1);
        var j0 = Math.floor(j),
          j1 = Math.min(oldGrid - 1, j0 + 1);
        var di = i - i0,
          dj = j - j0;
        var v00 = arr[i0 * oldGrid + j0],
          v01 = arr[i0 * oldGrid + j1];
        var v10 = arr[i1 * oldGrid + j0],
          v11 = arr[i1 * oldGrid + j1];
        return (
          v00 * (1 - di) * (1 - dj) +
          v01 * (1 - di) * dj +
          v10 * di * (1 - dj) +
          v11 * di * dj
        );
      };

      function bresenhamLine(i1, j1, i2, j2) {
        const points = [];
        const dx = Math.abs(i2 - i1);
        const dy = Math.abs(j2 - j1);
        const sx = i1 < i2 ? 1 : -1;
        const sy = j1 < j2 ? 1 : -1;
        let err = dx - dy;

        let i = i1;
        let j = j1;

        while (true) {
          points.push({ i, j });

          if (i === i2 && j === j2) break;

          const e2 = 2 * err;
          if (e2 > -dy) {
            err -= dy;
            i += sx;
          }
          if (e2 < dx) {
            err += dx;
            j += sy;
          }
        }
        return points;
      }

      function getImpulseWaveValue(timeOffset) {
        let value = 0;
        const period = IMPULSE_WAVELENGTH;
        const normalizedTime = (timeOffset % period) / period;

        if (IS_IMPULSE_HOLD) {
          if (IMPULSE_WAVE_TYPE === "CONSTANT") {
            value = 1.0;
          } else if (IMPULSE_WAVE_TYPE === "SINE") {
            value = Math.sin(normalizedTime * 2 * Math.PI);
          } else if (IMPULSE_WAVE_TYPE === "SQUARE") {
            value = Math.sign(Math.sin(normalizedTime * 2 * Math.PI));
          } else if (IMPULSE_WAVE_TYPE === "SAW") {
            value = 2 * normalizedTime - 1;
          }
        } else {
          if (timeOffset < period) {
            if (IMPULSE_WAVE_TYPE === "CONSTANT") {
              value = 1.0;
            } else if (IMPULSE_WAVE_TYPE === "SINE") {
              value = Math.sin(normalizedTime * Math.PI);
            } else if (IMPULSE_WAVE_TYPE === "SQUARE") {
              value = 1.0;
            } else if (IMPULSE_WAVE_TYPE === "SAW") {
              value = 1.0 - normalizedTime;
            }
          } else {
            return 0;
          }
        }
        return value;
      }

      function getBrushFalloff(dist, magnitude) {
        if (IMPULSE_SHAPE === "GAUSSIAN") {
          const hardnessFactor = 1.0 - brushHnd;
          const sigma = mRad * (0.5 * hardnessFactor);
          return Math.exp(-(dist * dist) / (2 * sigma * sigma)) * magnitude;
        } else {
          if (dist > mRad) return 0;
          const softZone = mRad * (1.0 - brushHnd);
          if (dist > softZone) {
            return magnitude * (1.0 - (dist - softZone) / (mRad - softZone));
          }
          return magnitude;
        }
      }

      function onResize() {
        if (!canvasContainer) return;
        var w = canvasContainer.clientWidth;
        const H = canvasContainer.clientHeight;
        if (H === 0) H = 1;
        camera.aspect = w / H;
        camera.updateProjectionMatrix();
        renderer.setSize(w, H);
        updCam();
      }

      function updCam() {
        phi = Math.min(179, Math.max(1, phi));
        rad = Math.min(250, Math.max(10, rad));
        camera.position
          .setFromSphericalCoords(rad, phi * 0.01745, theta * 0.01745)
          .add(TGT);
        camera.lookAt(TGT);
      }

      function setCameraView(azimuth, polar, distance) {
        theta = azimuth;
        phi = polar;
        rad = distance;
        updCam();
      }

function updateSimControls() {
    DT_FACTOR = parseFloat($("i-dt").value);
    VISCOSITY = parseFloat($("i-vis").value);
    SIM_STEPS_PER_FRAME = parseInt($("i-sim-steps").value);
    SIM_SAMPLES_PER_AUDIO_BUFFER = parseInt($("i-audio-buffer").value);
    
    $("l-dt").innerText = DT_FACTOR.toFixed(1);
    $("l-vis").innerText = VISCOSITY.toFixed(3);
    $("l-sim-steps").innerText = SIM_STEPS_PER_FRAME;
    $("l-audio-buffer").innerText = SIM_SAMPLES_PER_AUDIO_BUFFER;

    GLOBAL_DEN_ABSORPTION = parseFloat($("i-gden-abs").value);
    GLOBAL_DEN_REFRACTION = parseFloat($("i-gden-ref").value);
    $("l-gden-abs").innerText = GLOBAL_DEN_ABSORPTION.toFixed(3);
    $("l-gden-ref").innerText = GLOBAL_DEN_REFRACTION.toFixed(2);
}

      function togglePlayPause() {
        IS_PAUSED = !IS_PAUSED;
        if (IS_REALTIME_AUDIO) {
            if (IS_PAUSED) {
                if (REALTIME_GAIN && AUDIO_CONTEXT) {
                    REALTIME_GAIN.gain.setValueAtTime(REALTIME_GAIN.gain.value, AUDIO_CONTEXT.currentTime);
                    REALTIME_GAIN.gain.exponentialRampToValueAtTime(0.0001, AUDIO_CONTEXT.currentTime + 0.05); 
                }
            } else {
                 if (REALTIME_GAIN && AUDIO_CONTEXT) {
                    REALTIME_GAIN.gain.setValueAtTime(0.0, AUDIO_CONTEXT.currentTime);
                    REALTIME_GAIN.gain.exponentialRampToValueAtTime(0.5, AUDIO_CONTEXT.currentTime + 0.1); 
                }
            }
        }
      }

      function toggleExpand(header) {
        const targetId = header.dataset.target;
        const targetContent = $(targetId);
        const arrow = header.querySelector(".expand-arrow");

        if (targetContent) {
          const isExpanded = targetContent.classList.toggle("expanded");
          if (arrow) {
            arrow.style.transform = isExpanded
              ? "rotate(90deg)"
              : "rotate(0deg)";
          }
        }
      }

      function getExpansionState() {
        const state = {};
        document.querySelectorAll(".expandable-header").forEach((header) => {
          const targetId = header.dataset.target;
          if (targetId) {
            const targetContent = $(targetId);
            state[targetId] = targetContent
              ? targetContent.classList.contains("expanded")
              : false;
          }
        });
        return state;
      }

      function restoreExpansionState(state) {
        if (!state) return;

        document.querySelectorAll(".expandable-header").forEach((header) => {
          const targetId = header.dataset.target;
          const targetContent = $(targetId);
          const arrow = header.querySelector(".expand-arrow");

          if (targetContent && state[targetId] !== undefined) {
            if (state[targetId]) {
              targetContent.classList.add("expanded");
              if (arrow) arrow.style.transform = "rotate(90deg)";
            } else {
              targetContent.classList.remove("expanded");
              if (arrow) arrow.style.transform = "rotate(0deg)";
            }
          }
        });
      }

function defL(id) {
    let config = { ...BASE_LAYER_CFG };

    if (IS_3D_MODE) {
        config.visMode = "POINTS";
        config.shadingMode = BASE_LAYER_CFG.volShadingMode;
        config.gradientStops = BASE_LAYER_CFG.volGradientStops;
        config.gradientBias = BASE_LAYER_CFG.volGradientBias;
        config.gradientContrast = BASE_LAYER_CFG.volGradientContrast;
        config.pointFalloff = BASE_LAYER_CFG.pointFalloff;
    } else {
        config.visMode = "MESH";
        config.shadingMode = BASE_LAYER_CFG.shadingMode;
        config.gradientStops = BASE_LAYER_CFG.gradientStops;
        config.gradientBias = BASE_LAYER_CFG.gradientBias;
        config.gradientContrast = BASE_LAYER_CFG.gradientContrast;
        config.pointFalloff = BASE_LAYER_CFG.pointFalloff;
    }

    const preset = FORMULA_PRESETS[config.formulaKey];

    return {
        id: id,
        name: IS_3D_MODE ? `Slice ${id}` : `Layer ${id + 1}`,
        C: config.C,
        D: config.D,
        K: config.K,
        vis: true,
        intr: id === 0 || IS_3D_MODE,
        bnd: "FIXED",
        visMode: config.visMode,
        shadingMode: config.shadingMode,
        formulaKey: config.formulaKey,
        gradientBias: config.gradientBias,
        gradientContrast: config.gradientContrast,
        gradientStops: config.gradientStops.map((arr) => [...arr]),
        pointSize: config.pointSize,
        pointScaleFactor: config.pointScaleFactor,
        pointFalloff: config.pointFalloff,
        C_label: preset.C_label,
        D_label: preset.D_label,
    };
}

function addLayer() {
    const expansionState = getExpansionState();
    if (layers.length >= (IS_3D_MODE ? 100 : 8)) return;
    var newId = layerCounter++;
    layers.push(defL(newId));
    u.push(new Float32Array(GRID * GRID));
    u_prev.push(new Float32Array(GRID * GRID));
    u_aux.push(new Float32Array(GRID * GRID));
    den.push(new Float32Array(GRID * GRID));
    layerDensityModulations.push(new Float32Array(GRID * GRID));
    layerCouplingContributions.push(new Float32Array(GRID * GRID));
    syncM();
    updateLayerListUI();
    restoreExpansionState(expansionState);
    renderCouplingMatrixUI();
}
function removeLayer() {
    const expansionState = getExpansionState();
    if (layers.length <= 1) return;
    var idxToRemove = layers.length - 1;
    emits = emits.filter((e) => e.lIdx !== idxToRemove);
    VALVES = VALVES.filter((v) => v.lIdx !== idxToRemove);
    layers.pop();
    u.pop();
    u_prev.pop();
    den.pop();
    u_aux.pop();
    layerDensityModulations.pop();
    layerCouplingContributions.pop();

    GLOBAL_COUPLING_LINKS = GLOBAL_COUPLING_LINKS.filter(
        (link) =>
            link.sourceIdx !== idxToRemove && link.targetIdx !== idxToRemove,
    ).map((link) => ({
        ...link,
        sourceIdx:
            link.sourceIdx > idxToRemove ? link.sourceIdx - 1 : link.sourceIdx,
        targetIdx:
            link.targetIdx > idxToRemove ? link.targetIdx - 1 : link.targetIdx,
    }));

    syncM();
    syncE();
    updateLayerListUI();
    restoreExpansionState(expansionState);
    renderCouplingMatrixUI();
}


      function resetDensity() {
        den.forEach((d) => d.fill(0));
        syncM();
      }

      function resetGlobalDensity() {
        GLOBAL_DEN.fill(0);
        syncM();
      }

      function resetViewSettings() {
        fullResetConfig(DEFAULT_STATE_CONFIG);
      }

      function sdBox(p, b) {
        const d = new THREE.Vector2(Math.abs(p.x), Math.abs(p.y)).sub(b);
        return (
          Math.min(Math.max(d.x, d.y), 0.0) +
          new THREE.Vector2(Math.max(0.0, d.x), Math.max(0.0, d.y)).length()
        );
      }
      function sdEllipse(p, r) {
        const k1 = p.x / r.x;
        const k2 = p.y / r.y;
        return Math.sqrt(k1 * k1 + k2 * k2) - 1.0;
      }
      function sdParabola(p, f, w) {
        const parabola_y = (p.x * p.x) / (4 * f);
        let dist = p.y - parabola_y;
        if (Math.abs(p.x) > w / 2) return Infinity;
        return dist;
      }
      function sdHollowBox(p, b, t) {
        var outer = sdBox(p, b);
        var inner = sdBox(
          p,
          new THREE.Vector2(Math.max(0, b.x - t), Math.max(0, b.y - t)),
        );
        return Math.max(outer, -inner);
      }

      function mapSDF(i, j, centerI, centerJ, params) {
        const p = new THREE.Vector2(j - centerJ, i - centerI);
        let dist = Infinity;

        if (params.type === "SLAB") {
          dist = sdBox(
            p,
            new THREE.Vector2(params.width / 2, params.height / 2),
          );
        } else if (params.type === "HOLLOW_BOX") {
          dist = sdHollowBox(
            p,
            new THREE.Vector2(params.width / 2, params.height / 2),
            params.thickness,
          );
        } else if (params.type === "ELLIPSE") {
          dist = sdEllipse(
            p,
            new THREE.Vector2(params.radiusX, params.radiusY),
          );
        } else if (params.type === "PARABOLA") {
          const pd = sdParabola(p, params.focalLength, params.width);
          if (Math.abs(p.x) <= params.width / 2) {
            if (pd <= params.height / 2 && pd >= -params.height / 2) dist = -1;
            else dist = 1;
          } else dist = 1;
        } else if (params.type === "SLITS") {
          var barrier = sdBox(
            p,
            new THREE.Vector2(params.width / 2, params.height / 2),
          );
          var spacing = params.spacing;
          var n = Math.floor(params.slitCount);
          var slitW = params.slitWidth;
          var totalSpan = n * slitW + (n - 1) * spacing;
          var startX = -totalSpan / 2 + slitW / 2;
          var slitsDist = 10000;
          for (var k = 0; k < n; k++) {
            var slitCenter = new THREE.Vector2(
              startX + k * (slitW + spacing),
              0,
            );
            var slitBox = sdBox(
              p.clone().sub(slitCenter),
              new THREE.Vector2(slitW / 2, params.height / 2 + 2),
            );
            slitsDist = Math.min(slitsDist, slitBox);
          }
          dist = Math.max(barrier, -slitsDist);
        }
        return dist < 0 ? params.density : 0;
      }

      function getSDFParams() {
        return {
          type: $("sdf-type").value,
          density: parseFloat($("i-sdf-den").value),
          width: parseFloat($("sdf-w")?.value || currentSDFParams.width),
          height: parseFloat($("sdf-h")?.value || currentSDFParams.height),
          thickness: parseFloat($("sdf-thickness")?.value || 5),
          radiusX: parseFloat($("sdf-rx")?.value || currentSDFParams.radiusX),
          radiusY: parseFloat($("sdf-ry")?.value || currentSDFParams.radiusY),
          focalLength: parseFloat(
            $("sdf-f")?.value || currentSDFParams.focalLength,
          ),
          slitCount: parseFloat(
            $("sdf-slitCount")?.value || currentSDFParams.slitCount,
          ),
          slitWidth: parseFloat(
            $("sdf-slitWidth")?.value || currentSDFParams.slitWidth,
          ),
          spacing: parseFloat(
            $("sdf-spacing")?.value || currentSDFParams.spacing,
          ),
        };
      }

function placeShape(centerI, centerJ, layerIndex) {
        var p = getSDFParams();

        const centerLayer = IS_3D_MODE
          ? Math.floor(layers.length / 2)
          : layerIndex;

        const L_START = IS_3D_MODE ? 0 : centerLayer;
        const L_END = IS_3D_MODE ? layers.length : centerLayer + 1;

        const finalCenterI = IS_3D_MODE ? GRID / 2 : centerI;
        const finalCenterJ = IS_3D_MODE ? GRID / 2 : centerJ;

        const isGlobalStamp = SDF_STAMP_MODE === "GLOBAL";

        for (let r = 0; r < GRID; r++) {
          for (let c = 0; c < GRID; c++) {
            var d = mapSDF(r, c, finalCenterI, finalCenterJ, p);
            var idx = r * GRID + c;

            if (isGlobalStamp) {
              if (d > 0) {
	GLOBAL_DEN[idx] = d;
    // Enforce reflection/zeroing on ALL layers
    for (let L = 0; L < layers.length; L++) {
        u[L][idx] *= (1.0 - d);
        u_prev[L][idx] *= (1.0 - d);
    }
              }
            } else {
              for (let L = L_START; L < L_END; L++) {
                if (d > 0) {
                  let density_val;
                  if (SDF_STAMP_MODE === "REPLACE") density_val = d;
                  else if (SDF_STAMP_MODE === "ADD")
                    density_val = Math.min(1.0, den[L][idx] + d);
                  
                  den[L][idx] = density_val;
                  
                  // Enforce reflection/zeroing on current layer
                  u[L][idx] *= (1.0 - density_val);
                  u_prev[L][idx] *= (1.0 - density_val);
                }
              }
            }
          }
        }
        syncM();
      }

      function renderSDFPreview() {
        const cvs = $("sdf-preview"),
          ctx = cvs.getContext("2d");
        const W = cvs.width,
          H = cvs.height,
          SZ = W / GRID;
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, W, H);
        var p = getSDFParams();
        for (let i = 0; i < GRID; i++) {
          for (let j = 0; j < GRID; j++) {
            var d = mapSDF(i, j, GRID / 2, GRID / 2, p);
            if (d > 0) {
              ctx.fillStyle = `rgba(100,180,255,${d * 0.9 + 0.1})`;
              ctx.fillRect(j * SZ, i * SZ, SZ, SZ);
            }
          }
        }
        ctx.strokeStyle = "#555";
        ctx.beginPath();
        ctx.moveTo(W / 2, 0);
        ctx.lineTo(W / 2, H);
        ctx.moveTo(0, H / 2);
        ctx.lineTo(W, H / 2);
        ctx.stroke();
        $("l-sdf-den").innerText = parseFloat($("i-sdf-den").value).toFixed(2);
        currentSDFParams.density = parseFloat($("i-sdf-den").value);
      }

      function updateSDFControls() {
        const type = $("sdf-type").value;
        const d = $("sdf-dynamic-controls");
        d.innerHTML = "";
        const DEFS = {
          SLAB: [
            { n: "Width", id: "w", min: 1, max: GRID, def: 40 },
            { n: "Height", id: "h", min: 1, max: GRID, def: 20 },
          ],
          HOLLOW_BOX: [
            { n: "Width", id: "w", min: 5, max: GRID, def: 40 },
            { n: "Height", id: "h", min: 5, max: GRID, def: 20 },
            { n: "Thick", id: "thickness", min: 1, max: 20, def: 5 },
          ],
          ELLIPSE: [
            { n: "Rad X", id: "rx", min: 1, max: GRID / 2, def: 30 },
            { n: "Rad Y", id: "ry", min: 1, max: GRID / 2, def: 15 },
            { n: "Thickness", id: "thickness", min: 1, max: 10, def: 2 },
          ],
          PARABOLA: [
            { n: "Width", id: "w", min: 10, max: GRID, def: 40 },
            { n: "Focal", id: "f", min: 1, max: 50, def: 10 },
            { n: "Depth", id: "d", min: 1, max: 30, def: 5 },
          ],
          SLITS: [
            { n: "Width", id: "w", min: 10, max: GRID, def: 60 },
            { n: "Height", id: "h", min: 1, max: 20, def: 4 },
            { n: "Slits", id: "slitCount", min: 1, max: 10, def: 3 },
            { n: "Slit Gap", id: "slitWidth", min: 1, max: 10, def: 4 },
            { n: "Spacing", id: "spacing", min: 1, max: 20, def: 10 },
          ],
        };

        let commonDefs = DEFS[type] || [];

        commonDefs.forEach((p) => {
          var lbl = document.createElement("label");
          var val = document.createElement("span");
          lbl.innerText = p.n + ": ";
          val.classList.add("value-label");

          var inp = document.createElement("input");
          inp.type = "range";
          inp.id = "sdf-" + p.id;
          inp.min = p.min;
          inp.max = p.max;
          inp.step = p.max - p.min > 50 ? 1 : 0.5;

          let propName;
          if (p.id === "w") propName = "width";
          else if (p.id === "h") propName = "height";
          else if (p.id === "rx") propName = "radiusX";
          else if (p.id === "ry") propName = "radiusY";
          else if (p.id === "f") propName = "focalLength";
          else if (p.id === "thickness") propName = "thickness";
          else if (p.id === "slitCount") propName = "slitCount";
          else if (p.id === "slitWidth") propName = "slitWidth";
          else if (p.id === "spacing") propName = "spacing";
          else if (p.id === "d") propName = "height";

          inp.value = currentSDFParams[propName] || p.def;
          val.innerText = inp.value;

          inp.classList.add("custom-drag-slider");

          d.appendChild(lbl);
          lbl.appendChild(val);
          d.appendChild(inp);

          inp.oninput = (function (prop, valSpan) {
            return function (e) {
              currentSDFParams[prop] = parseFloat(e.target.value);
              valSpan.innerText = e.target.value;
              renderSDFPreview();
              updateStampPreview();
            };
          })(propName, val);
        });

        $("i-sdf-den").oninput = (e) => {
          $("l-sdf-den").innerText = parseFloat(e.target.value).toFixed(2);
          renderSDFPreview();
          currentSDFParams.density = parseFloat(e.target.value);
          updateStampPreview();
        };

        renderSDFPreview();
        updateStampPreview();
      }

      function setupSDFMenuHandlers() {
        $("sdf-type").onchange = updateSDFControls;

        $("i-sdf-den").classList.add("custom-drag-slider");

        $("i-sdf-den").oninput = (e) => {
          $("l-sdf-den").innerText = parseFloat(e.target.value).toFixed(2);
          renderSDFPreview();
          currentSDFParams.density = parseFloat(e.target.value);
        };

        EV("sdf-mode-toggle", "change", (e) => {
          SDF_STAMP_MODE = e.target.value;
        });

        $("sdf-close").onclick = () => {
          $("sdf-menu").style.display = "none";
          disposeMesh(stampPreviewMesh);
          stampPreviewMesh = null;
        };
        updateSDFControls();
      }

      function updateStampPreview() {
        if (stampPreviewMesh) {
          disposeMesh(stampPreviewMesh);
          stampPreviewMesh = null;
        }

        if (brush !== "SDF_PLACE" || $("sdf-menu").style.display === "none")
          return;

        const centerI = IS_3D_MODE ? GRID / 2 : sdfPlacementGrid.i;
        const centerJ = IS_3D_MODE ? GRID / 2 : sdfPlacementGrid.j;

        let targetLayers = [];
        if (IS_3D_MODE) {
          targetLayers.push(Math.floor(layers.length / 2));
        } else {
          const activeLayerIndex = layers.findIndex((l) => l.intr);
          if (activeLayerIndex !== -1) {
            targetLayers.push(activeLayerIndex);
          } else if (sdfPlacementGrid.lIdx !== undefined) {
            targetLayers.push(sdfPlacementGrid.lIdx);
          }
        }

        if (targetLayers.length === 0) return;

        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        const p = getSDFParams();
        const color = new THREE.Color(0x68b2f0);

        targetLayers.forEach((layerIndex) => {
          for (let r = 0; r < GRID; r++) {
            for (let c = 0; c < GRID; c++) {
              var d = mapSDF(r, c, centerI, centerJ, p);
              if (d > 0.01) {
                const worldPos = gtw(r, c, layerIndex);
                worldPos.y += 0.01;
                positions.push(worldPos.x, worldPos.y, worldPos.z);
                colors.push(color.r, color.g, color.b);
              }
            }
          }
        });

        if (positions.length > 0) {
          geometry.setAttribute(
            "position",
            new THREE.Float32BufferAttribute(positions, 3),
          );
          geometry.setAttribute(
            "color",
            new THREE.Float32BufferAttribute(colors, 3),
          );

          const material = new THREE.PointsMaterial({
            size: 0.5,
            vertexColors: true,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.8,
          });

          stampPreviewMesh = new THREE.Points(geometry, material);
          stampPreviewMesh.name = "SDF_PREVIEW";
          scene.add(stampPreviewMesh);
        }
      }

      function getShadingModeIndex(shadingMode) {
        return [
          "SPECULAR",
          "HEIGHT",
          "VELOCITY",
          "ENERGY",
          "DIVERGENCE",
          "VECTOR_RGB",
        ].indexOf(shadingMode);
      }
function createBaseUniforms(layer, vizCfg, volOpacity) {
        const source = IS_3D_MODE ? vizCfg : layer;
        const stops = IS_3D_MODE
          ? source.volGradientStops
          : source.gradientStops;

        var cols = [];
				var gradientFloats = new Float32Array(MAX_GRADIENT_STOPS * 3);
        for (let j = 0; j < MAX_GRADIENT_STOPS; j++) {
					let c_rgb_raw = stops[Math.min(j, stops.length - 1)]; 
    			let c_rgb = (Array.isArray(c_rgb_raw) && c_rgb_raw.length === 3) 
        ? c_rgb_raw 
        : [0, 0, 0];
          gradientFloats[j * 3 + 0] = c_rgb[0] / 255.0;
          gradientFloats[j * 3 + 1] = c_rgb[1] / 255.0;
          gradientFloats[j * 3 + 2] = c_rgb[2] / 255.0;
				}
        return {
          SUN_DIR: { value: sunDir },
          LIGHT_INTENSITY: { value: lInt },
          REFLECTIVITY: { value: REFLECTIVITY },
          SHADING_MODE: {
            value: getShadingModeIndex(
              IS_3D_MODE ? source.volShadingMode : source.shadingMode,
            ),
          },
          GRADIENT_BIAS: {
            value: IS_3D_MODE ? source.volGradientBias : source.gradientBias,
          },
          GRADIENT_CONTRAST: {
            value: IS_3D_MODE
              ? source.volGradientContrast
              : source.gradientContrast,
          },
          GRADIENT_STOPS: { value: gradientFloats },
          GRADIENT_STOPS_COUNT: { value: stops.length },
          VIS_MIN: { value: visMin },
          VIS_MAX: { value: visMax },
          uOpacity: { value: volOpacity },
          uShowDensity: { value: SHOW_DENSITY ? 1.0 : 0.0 },
          uExposure: { value: EXPOSURE },
          tCube: { value: cubeRenderTarget || createBlackCubemap() },
          uAlphaTest: { value: 0.0 },
          uZScale: { value: ZSC },
          uValveDensityBlend: { value: 0.0 }, // NEW: Added uniform
        };
      }


      function createMeshMaterial(baseUniforms) {
        return new THREE.ShaderMaterial({
          uniforms: baseUniforms,
          vertexShader: GLSL_MESH_VS,
          fragmentShader: GLSL_MESH_FS,
          transparent: true,
          side: 2,
          blending: THREE.NormalBlending,
          depthWrite: true,
          depthTest: true,
        });
      }

      function createPointsMaterial(baseUniforms, layer) {
        const uforms = {
          ...baseUniforms,
          uPointSize: { value: layer.pointSize },
          uPointScaleFactor: { value: layer.pointScaleFactor },
          uPointFalloff: { value: layer.pointFalloff },
          uModulateAlpha: { value: IS_ALPHA_MODULATION },
          uIs3DPoints: { value: IS_3D_MODE && layer.visMode === "POINTS" },
        };

        return new THREE.ShaderMaterial({
          uniforms: uforms,
          vertexShader: GLSL_POINTS_VS,
          fragmentShader: GLSL_POINTS_FS,
          transparent: true,
          side: 2,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          depthTest: true,
        });
      }

      function updTr() {
        updateVolumeBox();
        syncE();
      }

      function syncM() {
        const layerSpacing = getLayerSpacing();
        const totalHeight = (layers.length - 1) * layerSpacing;
        const centerYOffset = IS_3D_MODE ? totalHeight / 2 : 0;
        meshes.forEach(disposeMesh);
        meshes = [];
        var volOpacity = parseFloat($("i-vo").value);
        const vizCfg = BASE_LAYER_CFG;

        updateVolumeBox();

        layers.forEach((l, i) => {
          var g = new THREE.PlaneGeometry(50, 50, GRID - 1, GRID - 1).rotateX(
            -Math.PI / 2,
          );

          var count = g.attributes.position.count;
          g.setAttribute(
            "waveHeight",
            new THREE.BufferAttribute(new Float32Array(count), 1),
          );
          g.setAttribute(
            "waveVelocity",
            new THREE.BufferAttribute(new Float32Array(count), 1),
          );
          g.setAttribute(
            "aDensity",
            new THREE.BufferAttribute(new Float32Array(count), 1),
          );

          const baseUniforms = createBaseUniforms(l, vizCfg, volOpacity);
          const usePoints = l.visMode === "POINTS" || IS_3D_MODE;

          let material, mesh;

          if (usePoints) {
            material = createPointsMaterial(baseUniforms, l);
            mesh = new THREE.Points(g, material);
          } else {
            material = createMeshMaterial(baseUniforms);
            mesh = new THREE.Mesh(g, material);
          }

          mesh.position.y = centerYOffset - i * layerSpacing;
          mesh.userData = { lid: l.id, idx: i, visMode: l.visMode };
          mesh.renderOrder = i;
          scene.add(mesh);
          meshes.push(mesh);
        });
        updTr();
        syncE();
      }

function syncE() {
    emitMeshes.forEach(disposeMesh);
    emitMeshes = [];

    if (brush !== "EMITTER_PLACE" && emits.length === 0 && VALVES.length === 0) return;
    
    // --- Valve Rendering ---
    VALVES.forEach((v) => {
        var wPos = gtw(v.i, v.j, v.lIdx);
        
        const worldScale = 50.0 / (GRID > 1 ? GRID - 1 : 1);
        const valveSizeWorld = v.radius * 2 * worldScale; // Size is radius * 2
        
        // --- VISUAL STATE CONFIGURATION ---
        // A valve is OPEN when the key is pressed (isKeyPressed = true)
        const isValveOpen = v.isKeyPressed;
        
        // Define colors and opacity based on state
        let colorHex = isValveOpen ? 0x00ffaa : 0x005533; // Greenish for open, Dark for closed
        let opacity = isValveOpen ? 0.1 : 0.8; // Highly transparent when open, mostly opaque when closed
        const elevation = 1.0; // Render slightly higher than the layer plane
        
        // Use a PlaneGeometry to represent the quad
        var g = new THREE.PlaneGeometry(valveSizeWorld, valveSizeWorld);
        g.rotateX(-Math.PI / 2); // Rotate to lie flat on the grid plane
        
        var m = new THREE.Mesh(
          g,
          new THREE.MeshBasicMaterial({
            color: colorHex,
            transparent: true,
            opacity: opacity,
            side: THREE.DoubleSide,
          }),
        );
        
        // Center the quad at the valve's grid coordinates, elevated slightly
        m.position.set(wPos.x, wPos.y + elevation, wPos.z); 
        
        // Check for selection and adjust material for feedback
        if (v.id === selectedValveId) {
            m.material.color.set(0xffff00);
            m.material.opacity = 0.9;
        }

        m.userData = {
          eid: v.id,
          type: "VALVE",
          lIdx: v.lIdx,
          part: "BODY",
        };
        scene.add(m);
        emitMeshes.push(m);
    });

    // --- Emitter/Probe Rendering ---
    emits.forEach((e) => {
      var wPos = gtw(e.i, e.j, e.lIdx);
      
      let col = 0x00aaff;
      if (e.isProbe) {
          col = 0xe568b2;
      } else if (e.controlMode === "KEY_ACTIVATED" && e.isKeyPressed) {
          col = 0xffa500; // Orange for key activated
      } else if (e.controlMode === "ON") {
          col = 0x00ff00; // Green for always on
      } else {
          col = 0x00aaff; // Blue for OFF or standard
      }

      var sphereColor = e.id === selectedEmitterId ? 0xffff00 : col;

      if (e.geo === "LINE" && !e.isProbe) {
        var wPos2 = gtw(e.i2, e.j2, e.lIdx);

        var gS = new THREE.SphereGeometry(1, 16, 16);
        var mS = new THREE.Mesh(
          gS,
          new THREE.MeshBasicMaterial({
            color: sphereColor,
            transparent: true,
            opacity: 0.8,
          }),
        );
        mS.position.set(wPos.x, wPos.y + 0.5, wPos.z);
        mS.userData = {
          eid: e.id,
          type: e.type,
          lIdx: e.lIdx,
          part: "START",
        };
        scene.add(mS);
        emitMeshes.push(mS);

        var gE = new THREE.SphereGeometry(1, 16, 16);
        var mE = new THREE.Mesh(
          gE,
          new THREE.MeshBasicMaterial({
            color: sphereColor,
            transparent: true,
            opacity: 0.8,
          }),
        );
        mE.position.set(wPos2.x, wPos2.y + 0.5, wPos2.z);
        mE.userData = {
          eid: e.id,
          type: e.type,
          lIdx: e.lIdx,
          part: "END",
        };
        scene.add(mE);
        emitMeshes.push(mE);

        var vec = new THREE.Vector3().subVectors(wPos2, wPos);
        var dist = vec.length();
        var gL = new THREE.CylinderGeometry(0.3, 0.3, dist, 8);
        gL.rotateX(Math.PI / 2);
        var mL = new THREE.Mesh(
          gL,
          new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.6,
          }),
        );
        mL.position.copy(wPos).add(vec.multiplyScalar(0.5));
        mL.position.y += 0.5;
        mL.lookAt(new THREE.Vector3(wPos2.x, mL.position.y, wPos2.z));
        mL.userData = {
          eid: e.id,
          type: e.type,
          lIdx: e.lIdx,
          part: "BODY",
        };
        scene.add(mL);
        emitMeshes.push(mL);
      } else {
        var radius = e.isProbe ? 0.7 + e.probeRadius * 0.1 : 1.0;
        var g = new THREE.SphereGeometry(radius, 16, 16);
        var m = new THREE.Mesh(
          g,
          new THREE.MeshBasicMaterial({
            color: sphereColor,
            transparent: true,
            opacity: 0.8,
          }),
        );
        m.position.set(wPos.x, wPos.y + radius * 0.5, wPos.z);
        m.userData = {
          eid: e.id,
          type: e.type,
          lIdx: e.lIdx,
          part: "BODY",
        };
        scene.add(m);
        emitMeshes.push(m);
        
        if (e.isProbe) {
            const worldScale = 50.0 / (GRID > 1 ? GRID - 1 : 1);
            const probeRadiusWorld = e.probeRadius * worldScale;
            const probeGeo = new THREE.RingGeometry(probeRadiusWorld - 0.1, probeRadiusWorld + 0.1, 32);
            probeGeo.rotateX(-Math.PI / 2);
            const probeMat = new THREE.MeshBasicMaterial({
                color: 0xe568b2,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.5
            });
            const ringMesh = new THREE.Mesh(probeGeo, probeMat);
            ringMesh.position.set(wPos.x, wPos.y + 0.01, wPos.z);
            ringMesh.userData = { eid: e.id, part: "RING" };
            scene.add(ringMesh);
            emitMeshes.push(ringMesh);
        }
      }
    });
}


      function parseCustomFormula(formula) {
        const fnStr = `
                    try {
                        with (this.vars) {
                            return ${formula};
                        }
                    } catch (e) {
                        return this.vars.U_CURR;
                    }
                `;
        return new Function("vars", fnStr);
      }

      function updateCustomFormula() {
        const name = $("custom-name").value;
        const vars = $("custom-vars").value;
        const code = $("custom-code").value;

        GLOBAL_CUSTOM_FORMULA = { name, variables: vars, code };
        FORMULA_ERROR = null;

        if (!code.trim()) {
          FORMULA_ERROR = "Formula code cannot be empty.";
          COMPILED_CUSTOM_FUNCTION = null;
          $("err").innerText = `Model Error: ${FORMULA_ERROR}`;
          return false;
        }

        try {
          const variableMap = {};
          vars.split(";").forEach((pair) => {
            const parts = pair.split("=");
            if (parts.length === 2) {
              const key = parts[0].trim();
              const val = parseFloat(parts[1].trim());
              if (key && !isNaN(val)) variableMap[key] = val;
            }
          });

          const compiledFn = parseCustomFormula(code);
          const testScope = {
            U_CURR: 1.0,
            U_PREV: 1.0,
            LAP: 0.1,
            DT_FACTOR: 1.0,
            C_final: 0.25,
            D_final: 0.005,
            COUPLING_TERM: 0.01,
            EXT_COUPLING: 0.01,
            Math: Math,
            ...variableMap,
          };

          const testResult = compiledFn.call({ vars: testScope });

          if (isNaN(testResult) || testResult === undefined) {
            throw new Error("Formula returned non-numeric or undefined value.");
          }

          COMPILED_CUSTOM_FUNCTION = compiledFn;
          $("err").innerText = `Custom Model ready: ${name}`;
          return true;
        } catch (e) {
          FORMULA_ERROR = e.message;
          COMPILED_CUSTOM_FUNCTION = null;
          $("err").innerText = `Model Error: ${FORMULA_ERROR.substring(
            0,
            80,
          )}...`;
          return false;
        }
      }
      
function recordProbeData() {
    let totalValue = 0;
    let activeProbeCount = 0;

    emits.forEach(e => {
        if (!e.isProbe) return;
        
        const N = GRID;
        let sampledValue = 0;
        let samples = 0;
        const radSq = e.probeRadius * e.probeRadius;
        const L_IDX = e.lIdx;
        
        const u_arr = u[L_IDX];

        for (let r = -e.probeRadius; r <= e.probeRadius; r++) {
            for (let c = -e.probeRadius; c <= e.probeRadius; c++) {
                const rr = e.i + r;
                const cc = e.j + c;

                if (rr >= 0 && rr < N && cc >= 0 && cc < N) {
                    const distSq = r * r + c * c;
                    if (distSq <= radSq) {
                        const idx = rr * N + cc;
                        sampledValue += u_arr[idx]; 
                        samples++;
                    }
                }
            }
        }
        
        let averageValue = samples > 0 ? sampledValue / samples : 0;
        let recordedValue = averageValue * e.probeSensitivity;
        

        if (e.id === ACTIVE_PROBE_ID) {
            PROBE_HISTORY.push(recordedValue);
            while (PROBE_HISTORY.length > PROBE_HISTORY_LENGTH) {
                PROBE_HISTORY.shift();
            }
        }
        
        totalValue += recordedValue;
        activeProbeCount++;
    });
    
    if (ACTIVE_PROBE_ID && !IS_REALTIME_AUDIO) {
        const maxAbs = PROBE_HISTORY.reduce((max, val) => Math.max(max, Math.abs(val)), 0);
        renderProbeGraph(PROBE_HISTORY, maxAbs);
    }
    if (ACTIVE_PROBE_ID && IS_REALTIME_AUDIO) {
        if (PROBE_TIME_STEP_COUNTER % 60 === 0) {
            const maxAbs = PROBE_HISTORY.reduce((max, val) => Math.max(max, Math.abs(val)), 0);
            renderProbeGraph(PROBE_HISTORY, maxAbs);
        }
    }

    return activeProbeCount > 0 ? totalValue / activeProbeCount : 0;
}
function sim() {
    if (!layers.length) return;
    var N = GRID;

    TIME++;
    PROBE_TIME_STEP_COUNTER++;
    var DT2 = DT_FACTOR * DT_FACTOR;
    var max_wave_abs = 0.0;

    const USER_VISCOSITY_FACTOR = parseFloat($("i-vis").value);
    const MIN_DAMPING_FACTOR = 0.90; 
    const DAMPING_RANGE = 1.0 - MIN_DAMPING_FACTOR; 
    const GLOBAL_VISCOSITY_FACTOR = 1.0 - (USER_VISCOSITY_FACTOR * DAMPING_RANGE);

    recordProbeData(); 

    emits.forEach((e) => {
      if (e.isProbe) return;
        
      let isActive = e.controlMode === "ON" || (e.controlMode === "KEY_ACTIVATED" && e.isKeyPressed);
      if (!isActive) return;
        
      var phase = (TIME + e.off) * ((2 * Math.PI) / e.rt);
      var val = 0;
      if (e.shp === "STATIC") val = e.st;
      else if (e.shp === "SINE") val = e.st * Math.sin(phase);
      else if (e.shp === "COSINE") val = e.st * Math.cos(phase);
      else if (e.shp === "SQUARE") val = e.st * Math.sign(Math.sin(phase));
      else if (e.shp === "SAW")
        val = e.st * (2 * (((TIME + e.off) / e.rt) % 1) - 1);
      else if (e.shp === "NOISE") val = e.st * (Math.random() * 2 - 1);

      if (e.geo === "LINE") {
        const linePoints = bresenhamLine(e.i, e.j, e.i2, e.j2);
        if (linePoints.length > 0) {
          const energyPerPoint = val / linePoints.length;
          linePoints.forEach((p) => {
            var idx = p.i * N + p.j;
            if (e.st >= 0)
              u[e.lIdx][idx] += (energyPerPoint - u[e.lIdx][idx]) * 0.5;
            else {
              var damping = Math.min(
                1.0,
                (Math.abs(e.st) * 0.05) / linePoints.length,
              );
              u[e.lIdx][idx] *= 1.0 - damping;
              u_prev[e.lIdx][idx] *= 1.0 - damping;
            }
          });
        }
      } else {
        var idx = e.i * N + e.j;
        if (e.st >= 0) u[e.lIdx][idx] += (val - u[e.lIdx][idx]) * 0.5;
        else {
          var damping = Math.min(1.0, Math.abs(e.st) * 0.05);
          u[e.lIdx][idx] *= 1.0 - damping;
          u_prev[e.lIdx][idx] *= 1.0 - damping;
        }
      }
    });
        
    layerCouplingContributions.forEach(arr => arr.fill(0));
    layerDensityModulations.forEach(arr => arr.fill(0));
    
    // Immediate-Mode Density Application for Valves
    // Use layerDensityModulations[v.lIdx][idx] to carry the valve density
    
    VALVES.forEach((v) => {
        const targetDensity = v.isKeyPressed ? v.openDensity : v.closedDensity;
        const N = GRID;
        const HALF_SIZE = v.radius; 

        for (let r = -HALF_SIZE; r <= HALF_SIZE; r++) {
            for (let c = -HALF_SIZE; c <= HALF_SIZE; c++) {
                const rr = v.i + r;
                const cc = v.j + c;

                if (rr >= 0 && rr < N && cc >= 0 && cc < N) {
                    const idx = rr * N + cc;
                    // Store the valve density
                    layerDensityModulations[v.lIdx][idx] = targetDensity;
                }
            }
        }
    });


    var volK = 0.0;
    var effC = BASE_LAYER_CFG.C;
    var effD = BASE_LAYER_CFG.D;

    if (IS_3D_MODE && $("cb-iso").checked) {
      volK = effC * 1.0;
    } else if (IS_3D_MODE) {
      volK = BASE_LAYER_CFG.K;
    }

    const DT_factor_viscosity = DT_FACTOR * VISCOSITY;
    const K_FACTOR = IS_3D_MODE ? volK * DT_FACTOR : DT_FACTOR;
    
    // Coupling links logic remains here
    if (!IS_3D_MODE && GLOBAL_COUPLING_LINKS.length > 0) {
      GLOBAL_COUPLING_LINKS.forEach((link) => {
        if (
          link.sourceIdx < layers.length &&
          link.targetIdx < layers.length &&
          link.sourceIdx !== link.targetIdx
        ) {
          const sourceU = u[link.sourceIdx];
          const targetU = u[link.targetIdx];
          const sourcePrev = u_prev[link.sourceIdx];
          const rate = link.rate;
          const targetProp = link.targetProperty;
          const type = link.type;

          for (let ptr = 0; ptr < N * N; ptr++) {
            if (type === "ENERGY_EXCHANGE") {
              const diff = sourceU[ptr] - targetU[ptr];

              layerCouplingContributions[link.targetIdx][ptr] +=
                rate * diff;
              layerCouplingContributions[link.sourceIdx][ptr] -=
                rate * diff;
            } else if (type === "MODULATE_DENSITY") {
              let sourceAmp = Math.abs(sourceU[ptr]);

              let densityModulation = Math.max(
                0,
                Math.min(rate * sourceAmp, 1.0),
              );

              layerDensityModulations[link.targetIdx][ptr] =
                Math.max(layerDensityModulations[link.targetIdx][ptr], densityModulation);
            } else {
              let sourceValue = 0;
              if (targetProp === "AMPLITUDE") sourceValue = sourceU[ptr];
              else if (targetProp === "VELOCITY")
                sourceValue = sourceU[ptr] - sourcePrev[ptr];
              layerCouplingContributions[link.targetIdx][ptr] +=
                rate * (sourceValue - targetU[ptr]);
            }
          }
        }
      });
    }

    for (let idx = 0; idx < layers.length; idx++) {
      const l = layers[idx];
      const u_current_arr = u[idx];
      const u_prev_arr = u_prev[idx];
      const u_next_arr = u_aux[idx];
      const den_arr = den[idx]; // Persistent density
      const valve_den_arr = layerDensityModulations[idx]; // Valve/Modulated density

      const u_above_arr = idx < layers.length - 1 ? u[idx + 1] : null;
      const u_prev_above_arr = idx < layers.length - 1 ? u_prev[idx + 1] : null;
      
      const u_below_arr = idx > 0 ? u[idx - 1] : null;
      const u_prev_below_arr = idx > 0 ? u_prev[idx - 1] : null;

      const K_BELOW = idx > 0 ? layers[idx - 1].K : 0;
      const K_CURR = l.K;
      
      const finalC = IS_3D_MODE ? BASE_LAYER_CFG.C : l.C;
      const finalD = IS_3D_MODE ? BASE_LAYER_CFG.D : l.D;
      const effBnd = IS_3D_MODE ? l.bnd : l.bnd;
      
      const externalCouplingArr = layerCouplingContributions[idx];
      const formulaFn = (l.formulaKey === "CUSTOM" && COMPILED_CUSTOM_FUNCTION) ? COMPILED_CUSTOM_FUNCTION : null;
      
      const customVars = {};
      if (formulaFn) {
        GLOBAL_CUSTOM_FORMULA.variables.split(";").forEach((pair) => {
          const parts = pair.split("=");
          if (parts.length === 2) {
            customVars[parts[0].trim()] = parseFloat(parts[1].trim());
          }
        });
      }

      const S_factor = Math.sqrt(finalC) * DT_FACTOR;
      const murCoeff = (S_factor - 1.0) / (S_factor + 1.0);
      const isTopBoundary = (idx === 0);
      const isBottomBoundary = (idx === layers.length - 1);
      const isZAbsorbing = IS_3D_MODE && IS_VOL_ABSORBING_BND;
      const isIsotropic = IS_3D_MODE && $("cb-iso").checked;

      for (let i = 1; i < N - 1; i++) {
        const offset = i * N;
        for (let j = 1; j < N - 1; j++) {
          const ptr = offset + j;

          // Merge persistent density and immediate valve/modulation density
          // NOTE: This *still* ensures that valve/stamp density is applied.
          let effectiveDensity = Math.max(den_arr[ptr], valve_den_arr[ptr]);

          // --- REFLECTIVE/DAMPING LOGIC REMOVED ---
          // The code block that was here:
          // if (effectiveDensity > 0.99) { u_next_arr[ptr] = 0.0; continue; }
          // if (effectiveDensity > 0.0) { u_current_arr[ptr] *= (1.0 - effectiveDensity * 0.5); u_prev_arr[ptr] *= (1.0 - effectiveDensity * 0.5); }
          // --- END REFLECTIVE/DAMPING LOGIC REMOVED ---

          const globalDensity = GLOBAL_DEN[ptr];
          const U_CURR = u_current_arr[ptr];
          const U_PREV = u_prev_arr[ptr];

          let lap =
            u_current_arr[ptr + 1] +
            u_current_arr[ptr - 1] +
            u_current_arr[ptr + N] +
            u_current_arr[ptr - N];
          
          let COUPLING_TERM = 0; 

          if (isIsotropic) {
              
              if (isZAbsorbing && (isTopBoundary || isBottomBoundary)) {
                   const U_NEIGH_CURR = isTopBoundary ? u_above_arr[ptr] : u_below_arr[ptr];
                   const val_z_abc = U_NEIGH_CURR + murCoeff * (U_NEIGH_CURR - U_CURR);
                   u_next_arr[ptr] = val_z_abc;
                   continue;
              }
              
              let U_BELOW = u_below_arr ? u_below_arr[ptr] : U_CURR;
              let U_ABOVE = u_above_arr ? u_above_arr[ptr] : U_CURR;
              
              if (!isZAbsorbing) {
                  if (isTopBoundary) U_ABOVE = U_CURR;
                  if (isBottomBoundary) U_BELOW = U_CURR;
              }
              
              lap += U_ABOVE + U_BELOW;
              lap -= 6 * U_CURR;
              
          } else if (IS_3D_MODE) {
              
              lap -= 4 * U_CURR;
              
              let U_BELOW = u_below_arr ? u_below_arr[ptr] : U_CURR;
              let U_ABOVE = u_above_arr ? u_above_arr[ptr] : U_CURR;
              
              if (!isZAbsorbing) {
                  if (isTopBoundary) U_ABOVE = 0;
                  if (isBottomBoundary) U_BELOW = 0;
              }
              
              COUPLING_TERM = K_FACTOR * (U_ABOVE + U_BELOW - 2 * U_CURR);
          } else {
            lap -= 4 * U_CURR;
            const U_BELOW = u_below_arr ? u_below_arr[ptr] : U_CURR;
            const U_ABOVE = u_above_arr ? u_above_arr[ptr] : U_CURR;
            COUPLING_TERM =
              K_FACTOR * (K_BELOW * (U_BELOW - U_CURR) + K_CURR * (U_ABOVE - U_CURR));
          }

          // --- REFRACTION/SPEED MODULATION IS KEPT ---
          // effectiveDensity > 0 reduces C_density, slowing the wave down (refraction).
          const C_density = effectiveDensity > 0 ? finalC * (1 - effectiveDensity) : finalC;

          let C_final = C_density;
          if (globalDensity > 0) {
            const C_global_refract = 1.0 + globalDensity * (GLOBAL_DEN_REFRACTION - 1.0);
            C_final = C_density / C_global_refract;
          }

          let D_final = finalD;
          // The block below was copied/redundant in original - D_final remains finalD.
          /* if (globalDensity > 0) {
            const C_global_refract = 1.0 + globalDensity * (GLOBAL_DEN_REFRACTION - 1.0);
            C_final = C_density / C_global_refract;
          }
          */

          let EXTERNAL_COUPLING_TERM = externalCouplingArr[ptr] * DT_FACTOR;

          let val;
          
          if (formulaFn) {
            const scope = {
              U_CURR: U_CURR,
              U_PREV: U_PREV,
              LAP: lap,
              DT_FACTOR: DT_FACTOR,
              C_final: C_final,
              D_final: D_final,
              COUPLING_TERM: COUPLING_TERM,
              EXT_COUPLING: EXTERNAL_COUPLING_TERM,
              Math: Math,
              ...customVars,
            };
            val = formulaFn.call({ vars: scope });
          } else if (l.formulaKey === "WAVE") {
            val =
              2 * U_CURR -
              U_PREV +
              C_final * lap * DT2 - 
              D_final * (U_CURR - U_PREV) +
              COUPLING_TERM +
              EXTERNAL_COUPLING_TERM;
          } else if (l.formulaKey === "DIFFUSION") {
            val =
              U_CURR +
              DT_FACTOR *
                (C_final * lap - D_final * U_CURR) +
              COUPLING_TERM +
              EXTERNAL_COUPLING_TERM;
          } else if (l.formulaKey === "REACTION") {
            const F = l.C;
            const k = l.D;
            val =
              U_CURR +
              DT_FACTOR *
                (C_final * lap - F * U_CURR + k * (1.0 - U_CURR)) +
              COUPLING_TERM +
              EXTERNAL_COUPLING_TERM;
          } else {
            val =
              2 * U_CURR -
              U_PREV +
              C_final * lap * DT2 -
              D_final * (U_CURR - U_PREV);
          }
          
          val = Math.max(-10.0, Math.min(10.0, val));
          u_next_arr[ptr] = val;
          max_wave_abs = Math.max(max_wave_abs, Math.abs(val));
        }
      }

      for (let k = 0; k < N * N; k++) {
          u_next_arr[k] *= GLOBAL_VISCOSITY_FACTOR;
          valve_den_arr[k] = 0; // Clear valve overlay after use
      }

      const effC2D = IS_3D_MODE ? BASE_LAYER_CFG.C : l.C;
      const S_2D = Math.sqrt(effC2D) * DT_FACTOR;
      const murCoeff2D = (S_2D - 1.0) / (S_2D + 1.0);
      
      // Boundary condition logic remains to prevent wrap-around at grid edges.
      // This is necessary for the stability of the FDTD scheme itself.
      if (effBnd === "ABSORBING" || (IS_3D_MODE && IS_VOL_ABSORBING_BND)) {
        for (let k = 1; k < N - 1; k++) {
          let ptrTop = k;
          let ptrTopNeigh = ptrTop + N;
          u_next_arr[ptrTop] =
            u_current_arr[ptrTopNeigh] +
            murCoeff2D * (u_next_arr[ptrTopNeigh] - u_current_arr[ptrTop]);

          let ptrBot = (N - 1) * N + k;
          let ptrBotNeigh = ptrBot - N;
          u_next_arr[ptrBot] =
            u_current_arr[ptrBotNeigh] +
            murCoeff2D * (u_next_arr[ptrBotNeigh] - u_current_arr[ptrBot]);
        }

        for (let k = 1; k < N - 1; k++) {
          let ptrLeft = k * N;
          let ptrLeftNeigh = ptrLeft + 1;
          u_next_arr[ptrLeft] =
            u_current_arr[ptrLeftNeigh] +
            murCoeff2D * (u_next_arr[ptrLeftNeigh] - u_current_arr[ptrLeft]);

          let ptrRight = k * N + N - 1;
          let ptrRightNeigh = ptrRight - 1;
          u_next_arr[ptrRight] =
            u_current_arr[ptrRightNeigh] +
            murCoeff2D *
              (u_next_arr[ptrRightNeigh] - u_current_arr[ptrRight]);
        }
        
        u_next_arr[0] = (u_next_arr[1] + u_next_arr[N]) * 0.5;
        u_next_arr[N - 1] =
          (u_next_arr[N - 2] + u_next_arr[2 * N - 1]) * 0.5;
        u_next_arr[(N - 1) * N] =
          (u_next_arr[(N - 1) * N + 1] + u_next_arr[(N - 2) * N]) * 0.5;
        u_next_arr[N * N - 1] =
          (u_next_arr[N * N - 2] + u_next_arr[(N - 1) * N - 1]) * 0.5;

      } else {
        // Fixed boundary (wall) on grid edges
        for (let k = 0; k < N; k++) {
          u_next_arr[k] = 0;
          u_next_arr[(N - 1) * N + k] = 0;
          u_next_arr[k * N] = 0;
          u_next_arr[k * N + N - 1] = 0;
        }
      }
    }

    var temp = u_prev;
    u_prev = u;
    u = u_aux;
    u_aux = temp;
    MAX_WAVE_ABS = max_wave_abs;
}


      function lerp(a, b, t) {
        return a + (b - a) * t;
      }

function loop() {
        requestAnimationFrame(loop);

        const toggleBtn = $("btn-toggle-play");
        if (IS_PAUSED) {
          toggleBtn.textContent = "Play";
          toggleBtn.style.background = "#280745";
          toggleBtn.style.borderColor = "#28a745";
        } else {
          toggleBtn.textContent = "Pause";
          toggleBtn.style.background = "#082737";
          toggleBtn.style.borderColor = "var(--color-warning)";
          
          if (!IS_REALTIME_AUDIO) {
              for (let i = 0; i < SIM_STEPS_PER_FRAME; i++) {
                  sim();
              }
          }
        }
        
        if (ACTIVE_PROBE_ID && !IS_PAUSED) {
            updateProbeMenuInfo();
            if (TIME % 5 === 0) {
                const maxAbs = PROBE_HISTORY.reduce((max, val) => Math.max(max, Math.abs(val)), 0);
                renderProbeGraph(PROBE_HISTORY, maxAbs);
            }
        }

        if (selectedValveId) {
            updateValveMenuInfo();
        }

        if (selectedEmitterId) {
            updateEmitterMenuInfo();
        }

        if (AUTO_EXPOSURE) {
          const maxWaveValue = Math.max(0.01, MAX_WAVE_ABS);
          const DisplayReferenceMax = 0.5;
          const maxVisualIntensity =
            maxWaveValue * 0.2 * BASE_POINT_SETTINGS.pointScaleFactor;
          let targetExposure = DisplayReferenceMax / maxVisualIntensity;

          targetExposure = Math.max(0.0, Math.min(2.0, targetExposure));

          EXPOSURE = lerp(EXPOSURE, targetExposure, 0.05);

          $("i-exposure").value = EXPOSURE;
          $("l-exposure").innerText = EXPOSURE.toFixed(2);
        }

        if (
          isContinuousBrushActive &&
          (brush === "DISTURBANCE" || brush === "DENSITY_PAINT")
        ) {
          if (activeBrushHit) {
            interact(activeBrushHit.i, activeBrushHit.j, activeBrushHit.lIdx);
          }
        }

        if (brush === "SDF_PLACE" && $("sdf-menu").style.display === "block") {
          updateStampPreview();
        }

        meshes.forEach((m, i) => {
          if (!layers[i]) return;
          const l = layers[i];
          if (!l.vis) {
            m.visible = false;
            return;
          }
          m.visible = true;

          const isMeshVis = !IS_3D_MODE && m.userData.visMode === "MESH";

          var pos = m.geometry.attributes.position.array;
          var hAttr = m.geometry.attributes.waveHeight.array;
          var vAttr = m.geometry.attributes.waveVelocity.array;
          var dAttr = m.geometry.attributes.aDensity.array;

          let isValveDensityPresentOnLayer = false;

          for (let k = 0; k < GRID * GRID; k++) {
            hAttr[k] = u[i][k];
            vAttr[k] = u[i][k] - u_prev[i][k];
            
            let combinedDensity = den[i][k];
            
            // Check if the immediate-mode valve density is higher than the persistent density
            if (layerDensityModulations[i][k] > combinedDensity) {
                combinedDensity = layerDensityModulations[i][k];
                isValveDensityPresentOnLayer = true; // Flag for this layer
            }

            combinedDensity = Math.max(combinedDensity, GLOBAL_DEN[k]);
            
            dAttr[k] = Math.min(1.0, combinedDensity);

            if (isMeshVis) {
              pos[k * 3 + 1] = u[i][k] * ZSC * 0.1;
            }
          }
          m.geometry.attributes.waveHeight.needsUpdate = true;
          m.geometry.attributes.waveVelocity.needsUpdate = true;
          m.geometry.attributes.aDensity.needsUpdate = true;
          if (isMeshVis) m.geometry.attributes.position.needsUpdate = true;

          if (isMeshVis) m.geometry.computeVertexNormals();
          if (m.material.uniforms) {
            m.material.uniforms.SUN_DIR.value = sunDir;
            m.material.uniforms.LIGHT_INTENSITY.value = lInt;
            m.material.uniforms.REFLECTIVITY.value = REFLECTIVITY;
            m.material.uniforms.VIS_MIN.value = visMin;
            m.material.uniforms.VIS_MAX.value = visMax;
            m.material.uniforms.uExposure.value = EXPOSURE;
            if (m.material.uniforms.uZScale) {
              m.material.uniforms.uZScale.value = ZSC;
            }
            if (m.material.uniforms.uPointSize) {
              m.material.uniforms.uPointSize.value = l.pointSize;
            }
            if (m.material.uniforms.uPointScaleFactor) {
              m.material.uniforms.uPointScaleFactor.value = l.pointScaleFactor;
            }
            if (m.material.uniforms.uPointFalloff) {
              m.material.uniforms.uPointFalloff.value = l.pointFalloff;
            }
            
            // NEW/FIXED: Set uValveDensityBlend to 1.0 if there is ANY valve on this layer
            if (m.material.uniforms.uValveDensityBlend) {
                m.material.uniforms.uValveDensityBlend.value = isValveDensityPresentOnLayer ? 1.0 : 0.0;
            }
          }
        });
        updCam();
        renderer.render(scene, camera);
}

      function updateLayerParamUI(layerIndex, prop) {
        const l = layers[layerIndex];
        const el = $(`l-${prop}-${l.id}`);
        if (el) {
          el.innerText = l[prop].toFixed(
            prop === "C" || prop === "D" || prop === "K" ? 3 : 1,
          );
        }
        if (prop === "vis") {
          const checkbox = $(`layer_vis_checkbox_${l.id}`);
          if (checkbox) checkbox.checked = l.vis;
        }
        if (prop === "intr") {
          const checkbox = $(`layer_intr_checkbox_${l.id}`);
          if (checkbox) checkbox.checked = l.intr;
        }
      }
function cast(e) {
        var mouse = nm(e);
        raycaster.setFromCamera(mouse, camera);

        // Find intersections with Emitters/Valves
        var ems = raycaster.intersectObjects(emitMeshes);
        if (ems.length > 0)
          return {
            obj: ems[0].object,
            lIdx: ems[0].object.userData.lIdx,
            point: ems[0].point,
            type: ems[0].object.userData.type,
          };

        const meshCandidates = meshes.filter((m) => m.visible);

        // Find intersections with the wave surfaces (meshes)
        var ps = raycaster.intersectObjects(meshCandidates);
        raycaster.params.Points.threshold = IS_3D_MODE ? 2.0 : 1.0;

        if (ps.length)
          return {
            ...wtg(ps[0].point.x, ps[0].point.z),
            lIdx: ps[0].object.userData.idx,
            point: ps[0].point,
            face: ps[0].face,
            type: "MESH",
          };
        return null;
      }

function interact(i, j, l) {
        if (l >= layers.length) return;
				if (brush === "DENSITY_PAINT" && IS_3D_MODE) {
            return;
        }
        if (brush === "EMITTER_PLACE" || brush === "VALVE_PLACE") {
          return;
        }

        const L_CENTER = l < 0 ? 0 : l;
        const L_START = IS_3D_MODE ? Math.max(0, L_CENTER - mRad) : L_CENTER;
        const L_END = IS_3D_MODE
          ? Math.min(layers.length, L_CENTER + mRad + 1)
          : L_CENTER + 1;

        const DX = 50.0 / (GRID - 1);
        const layerSpacing = getLayerSpacing();
        const Z_SCALE_FACTOR = DX > 0 ? layerSpacing / DX : 1.0;

        const maxDistSq = mRad * mRad;
        const isGlobalDensityBrush = brush === "DENSITY_PAINT" && l === -1;

        let waveValue = 0;
        if (brush === "DISTURBANCE") {
          if (!IS_3D_MODE && l >= 0 && !layers[L_CENTER].intr) return;

          if (IS_IMPULSE_HOLD) {
            waveValue = getImpulseWaveValue(TIME);
          } else {
            const timeSincePulse = TIME - pulseStartTime;
            if (timeSincePulse < IMPULSE_WAVELENGTH) {
              waveValue = getImpulseWaveValue(timeSincePulse);
            } else {
              waveValue = 0;
            }
          }
          if (waveValue === 0) return;
        }

        for (let r = -mRad; r <= mRad; r++)
          for (let c = -mRad; c <= mRad; c++) {
            var rr = i + r,
              cc = j + c;
            if (rr >= 1 && rr < GRID - 1 && cc >= 1 && cc < GRID - 1) {
              var idx = rr * GRID + cc;

              const dist2DSq = r * r + c * c;

              for (let L = L_START; L < L_END; L++) {
                let distSq;
                if (IS_3D_MODE) {
                  const dL = L - L_CENTER;
                  const dL_scaled_sq =
                    dL * Z_SCALE_FACTOR * (dL * Z_SCALE_FACTOR);

                  distSq = dist2DSq + dL_scaled_sq;
                } else {
                  if (L !== L_CENTER) continue;
                  distSq = dist2DSq;
                }

                if (distSq <= maxDistSq) {
                  const dist = Math.sqrt(distSq);
                  const falloff = getBrushFalloff(dist, 1.0);

                  if (brush === "DISTURBANCE") {
                    var v = IMPULSE_MAGNITUDE * falloff * waveValue;
                    u[L][idx] += v;
                  } else if (brush === "DENSITY_PAINT") {
                    let currentDensity = isGlobalDensityBrush
                      ? GLOBAL_DEN[idx]
                      : den[L][idx];

                    if (falloff * DEN_FLOW_RATE > 0) {
                      if (DEN_BRUSH_MODE === "REPLACE") {
                        currentDensity = Math.max(
                          0,
                          Math.min(
                            1,
                            currentDensity +
                              (mVal - currentDensity) * falloff * DEN_FLOW_RATE,
                          ),
                        );
                      } else if (DEN_BRUSH_MODE === "ADD") {
                        if (mVal > 0) {
                          currentDensity = Math.max(
                            0,
                            Math.min(
                              1,
                              currentDensity + mVal * falloff * DEN_FLOW_RATE,
                            ),
                          );
                        }
                      } else if (DEN_BRUSH_MODE === "SUBTRACT") {
                        if (mVal > 0) {
                          currentDensity = Math.max(
                            0,
                            Math.min(
                              1,
                              currentDensity - mVal * falloff * DEN_FLOW_RATE,
                            ),
                          );
                        }
                      }

                      if (isGlobalDensityBrush) {
                        GLOBAL_DEN[idx] = currentDensity;
                        u[L][idx] *= (1.0 - currentDensity);
                        u_prev[L][idx] *= (1.0 - currentDensity);
                      } else {
                        den[L][idx] = currentDensity;
                        u[L][idx] *= (1.0 - currentDensity);
                        u_prev[L][idx] *= (1.0 - currentDensity);
                      }
                    }
                  }
                }
              }
            }
          }

        if (brush === "DENSITY_PAINT") {
          syncM();
        }
      }

function resizeSim(newGrid) {
    const expansionState = getExpansionState();
    if (newGrid === GRID) return;
    var oldGrid = GRID;
    
    var newU = [], newUPrev = [], newDen = [], newGlobalDen = new Float32Array(newGrid * newGrid);

    layers.forEach((l, idx) => {
        var nU = new Float32Array(newGrid * newGrid);
        var nUP = new Float32Array(newGrid * newGrid);
        var nD = new Float32Array(newGrid * newGrid);
        for (let r = 0; r < newGrid; r++) {
            for (let c = 0; c < newGrid; c++) {
                var nr = r / (newGrid - 1);
                var nc = c / (newGrid - 1);
                nU[r * newGrid + c] = sampleGrid(u[idx], oldGrid, nr, nc);
                nUP[r * newGrid + c] = sampleGrid(u_prev[idx], oldGrid, nr, nc);
                nD[r * newGrid + c] = sampleGrid(den[idx], oldGrid, nr, nc);
            }
        }
        newU.push(nU);
        newUPrev.push(nUP);
        newDen.push(nD);
    });

    for (let r = 0; r < newGrid; r++) {
        for (let c = 0; c < newGrid; c++) {
            var nr = r / (newGrid - 1);
            var nc = c / (newGrid - 1);
            newGlobalDen[r * newGrid + c] = sampleGrid(
                GLOBAL_DEN,
                oldGrid,
                nr,
                nc,
            );
        }
    }

    GRID = newGrid;
    $("l-res").innerText = GRID;
    
    initData(true); 
    
    u = newU;
    u_prev = newUPrev;
    u_aux = newU.map(() => new Float32Array(GRID * GRID));
    den = newDen;
    GLOBAL_DEN = newGlobalDen;

    var ratio = (GRID - 1) / (oldGrid - 1);
    emits.forEach((e) => {
        e.i = Math.round(e.i * ratio);
        e.j = Math.round(e.j * ratio);
        if (e.i2) e.i2 = Math.round(e.i2 * ratio);
        if (e.j2) e.j2 = Math.round(e.j2 * ratio);
    });
    VALVES.forEach((v) => {
        v.i = Math.round(v.i * ratio);
        v.j = Math.round(v.j * ratio);
    });


    syncE();
    syncM();
    restoreExpansionState(expansionState);
}

      function clearSimulation() {
        emits = emits.filter((e) => e.type !== "EMITTER_LINE_DRAG");
        u.forEach((arr) => arr.fill(0));
        u_prev.forEach((arr) => arr.fill(0));
        selectedEmitterId = null;
        selectedValveId = null;
        updateEmitterInspector();
        updateValveInspector();
        syncE();
      }

function getAppState() {
    return {
        global: {
            GRID,
            GAP,
            ZSC,
            DT_FACTOR,
            VISCOSITY,
            lInt,
            REFLECTIVITY,
            visMin,
            visMax,
            IS_3D_MODE,
            VOL_LAYERS,
            sunPitch: +$("i-sp").value,
            sunYaw: +$("i-sy").value,
            GLOBAL_DEN_ABSORPTION: GLOBAL_DEN_ABSORPTION,
            GLOBAL_DEN_REFRACTION: GLOBAL_DEN_REFRACTION,
            EXPOSURE: EXPOSURE,
            AUTO_EXPOSURE: AUTO_EXPOSURE,
        },
        layers: layers.map((l, i) => ({
            ...l,
            den: Array.from(den[i]),
            gradientStops: l.gradientStops.map((arr) => [...arr]),
            volShadingMode: BASE_LAYER_CFG.volShadingMode,
            volGradientStops: BASE_LAYER_CFG.volGradientStops.map((arr) => [...arr]),
            volGradientBias: BASE_LAYER_CFG.volGradientBias,
            volGradientContrast: BASE_LAYER_CFG.volGradientContrast,
            pointFalloff: BASE_LAYER_CFG.pointFalloff,
        })),
        emits: emits.map((e) => ({
            i: e.i,
            j: e.j,
            lIdx: e.lIdx,
            type: e.type,
            st: e.st,
            rt: e.rt,
            off: e.off,
            shp: e.shp,
            geo: e.geo,
            i2: e.i2,
            j2: e.j2,
            isProbe: e.isProbe || false,
            probeRadius: e.probeRadius || BASE_PROBE_CFG.probeRadius,
            probeSensitivity: e.probeSensitivity || BASE_PROBE_CFG.probeSensitivity,
            controlMode: e.controlMode || "OFF", // NEW
            key: e.key || BASE_EMITTER_CFG.key, // NEW
        })),
        valves: VALVES.map((v) => ({
            i: v.i,
            j: v.j,
            lIdx: v.lIdx,
            radius: v.radius,
            key: v.key,
            openDensity: v.openDensity,
            closedDensity: v.closedDensity,
        })),
        camera: { rad, theta, phi },
        globalDen: Array.from(GLOBAL_DEN),
        globalCoupling: GLOBAL_COUPLING_LINKS,
        customFormula: GLOBAL_CUSTOM_FORMULA,
    };
}

      function setAppState(cfg) {
        GRID = cfg.global.GRID || DEFAULT_STATE_CONFIG.global.GRID;
        $("i-res").value = GRID;
        GAP = cfg.global.GAP || DEFAULT_STATE_CONFIG.global.GAP;
        $("i-gap").value = GAP;
        ZSC = cfg.global.ZSC || DEFAULT_STATE_CONFIG.global.ZSC;
        $("i-z").value = ZSC;
        DT_FACTOR =
          cfg.global.DT_FACTOR || DEFAULT_STATE_CONFIG.global.DT_FACTOR;
        $("i-dt").value = DT_FACTOR;
        VISCOSITY =
          cfg.global.VISCOSITY || DEFAULT_STATE_CONFIG.global.VISCOSITY;
        $("i-vis").value = VISCOSITY;
        lInt = cfg.global.lInt || DEFAULT_STATE_CONFIG.global.lInt;
        $("i-li").value = lInt;
        REFLECTIVITY =
          cfg.global.REFLECTIVITY || DEFAULT_STATE_CONFIG.global.REFLECTIVITY;
        $("i-refl").value = REFLECTIVITY;
        visMin = cfg.global.visMin || DEFAULT_STATE_CONFIG.global.visMin;
        $("i-vis-min").value = visMin;
        visMax = cfg.global.visMax || DEFAULT_STATE_CONFIG.global.visMax;
        $("i-vis-max").value = visMax;
        GLOBAL_DEN_ABSORPTION =
          cfg.global.GLOBAL_DEN_ABSORPTION ||
          DEFAULT_STATE_CONFIG.global.GLOBAL_DEN_ABSORPTION;
        $("i-gden-abs").value = GLOBAL_DEN_ABSORPTION;
        GLOBAL_DEN_REFRACTION =
          cfg.global.GLOBAL_DEN_REFRACTION ||
          DEFAULT_STATE_CONFIG.global.GLOBAL_DEN_REFRACTION;
        $("i-gden-ref").value = GLOBAL_DEN_REFRACTION;

        EXPOSURE = cfg.global.EXPOSURE || DEFAULT_STATE_CONFIG.global.EXPOSURE;
        $("i-exposure").value = EXPOSURE;
        AUTO_EXPOSURE =
          cfg.global.AUTO_EXPOSURE || DEFAULT_STATE_CONFIG.global.AUTO_EXPOSURE;
        $("cb-auto-exposure").checked = AUTO_EXPOSURE;

        $("i-sp").value =
          cfg.global.sunPitch || DEFAULT_STATE_CONFIG.global.sunPitch;
        $("i-sy").value =
          cfg.global.sunYaw || DEFAULT_STATE_CONFIG.global.sunYaw;

        if (cfg.layers && cfg.layers.length > 0) {
          BASE_LAYER_CFG.volShadingMode =
            cfg.layers[0].volShadingMode || BASE_LAYER_CFG.volShadingMode;
          BASE_LAYER_CFG.volGradientStops =
            cfg.layers[0].volGradientStops || DEFAULT_VOL_GRADIENT_STOPS;
          BASE_LAYER_CFG.volGradientBias =
            cfg.layers[0].volGradientBias || BASE_LAYER_CFG.volGradientBias;
          BASE_LAYER_CFG.volGradientContrast =
            cfg.layers[0].volGradientContrast ||
            BASE_LAYER_CFG.volGradientContrast;
          BASE_LAYER_CFG.pointFalloff =
            cfg.layers[0].pointFalloff || BASE_LAYER_CFG.pointFalloff;
        }

        const tempConfig = {
          ...cfg,
          IS_3D_MODE:
            cfg.IS_3D_MODE !== undefined
              ? cfg.IS_3D_MODE
              : cfg.global.IS_3D_MODE || DEFAULT_STATE_CONFIG.global.IS_3D_MODE,
          VOL_LAYERS:
            cfg.VOL_LAYERS !== undefined
              ? cfg.VOL_LAYERS
              : cfg.global.VOL_LAYERS || DEFAULT_STATE_CONFIG.global.VOL_LAYERS,
        };

        if (cfg.customFormula) {
          GLOBAL_CUSTOM_FORMULA = cfg.customFormula;
          $("custom-name").value = GLOBAL_CUSTOM_FORMULA.name;
          $("custom-vars").value = GLOBAL_CUSTOM_FORMULA.variables;
          $("custom-code").value = GLOBAL_CUSTOM_FORMULA.code;
          updateCustomFormula();
        }

        fullResetConfig(tempConfig);
        updateSimControls();

        $("i-vo").oninput();
      }

      function savePresetFile() {
        try {
          const state = getAppState();
          const json = JSON.stringify(state, null, 2);
          const blob = new Blob([json], { type: "text/plain" });
          const a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = "wave_sim_config.txt";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          $("err").innerText = "Configuration saved successfully!";
        } catch (e) {
          $("err").innerText = "Error saving config: " + e.message;
        }
      }

      function loadPresetFile() {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = ".txt,.json";
        input.onchange = (e) => {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = function (event) {
            try {
              const content = event.target.result;
              const config = JSON.parse(content);
              if (config.global && config.layers) {
                setAppState(config);
                $("err").innerText = "Configuration loaded successfully!";
              } else {
                throw new Error("Invalid configuration file structure.");
              }
            } catch (err) {
              $("err").innerText = "Error loading config: " + err.message;
            }
          };
          reader.readAsText(file);
        };
        input.click();
      }

      function saveFormulaFile() {
        try {
          const formula = GLOBAL_CUSTOM_FORMULA;
          const json = JSON.stringify(formula, null, 2);
          const blob = new Blob([json], { type: "text/plain" });
          const a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = `formula_${formula.name.replace(/\s/g, "_")}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          $("err").innerText = `Formula '${formula.name}' saved successfully!`;
        } catch (e) {
          $("err").innerText = "Error saving formula: " + e.message;
        }
      }

      function loadFormulaFile() {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = ".json,.txt";
        input.onchange = (e) => {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = function (event) {
            try {
              const content = event.target.result;
              const formula = JSON.parse(content);
              if (formula.name && formula.code) {
                GLOBAL_CUSTOM_FORMULA = formula;
                $("custom-name").value = formula.name;
                $("custom-vars").value = formula.variables || "";
                $("custom-code").value = formula.code;
                updateCustomFormula();
                $("err").innerText =
                  `Formula '${formula.name}' loaded successfully!`;
              } else {
                throw new Error("Invalid formula file structure.");
              }
            } catch (err) {
              $("err").innerText = "Error loading formula: " + err.message;
            }
          };
          reader.readAsText(file);
        };
        input.click();
      }

function fullResetConfig(config) {
    TIME = 0;
    layerCounter = 0;
    emits = [];
    VALVES = [];
    shapes = [];
    PROBE_HISTORY = [];
    ACTIVE_PROBE_ID = null;
    $("probe-menu").style.display = 'none';
    stopAudio();
    stopRealtimeAudio();

    let cfg = config || DEFAULT_STATE_CONFIG;

    GRID = cfg.global.GRID || DEFAULT_STATE_CONFIG.global.GRID;
    $("i-res").value = GRID;
    GAP = cfg.global.GAP || DEFAULT_STATE_CONFIG.global.GAP;
    $("i-gap").value = GAP;
    ZSC = cfg.global.ZSC || DEFAULT_STATE_CONFIG.global.ZSC;
    $("i-z").value = ZSC;
    DT_FACTOR =
        cfg.global.DT_FACTOR || DEFAULT_STATE_CONFIG.global.DT_FACTOR;
    $("i-dt").value = DT_FACTOR;
    VISCOSITY =
        cfg.global.VISCOSITY || DEFAULT_STATE_CONFIG.global.VISCOSITY;
    $("i-vis").value = VISCOSITY;
    lInt = cfg.global.lInt || DEFAULT_STATE_CONFIG.global.lInt;
    $("i-li").value = lInt;
    REFLECTIVITY =
        cfg.global.REFLECTIVITY || DEFAULT_STATE_CONFIG.global.REFLECTIVITY;
    $("i-refl").value = REFLECTIVITY;
    visMin = cfg.global.visMin || DEFAULT_STATE_CONFIG.global.visMin;
    $("i-vis-min").value = visMin;
    visMax = cfg.global.visMax || DEFAULT_STATE_CONFIG.global.visMax;
    $("i-vis-max").value = visMax;
    GLOBAL_DEN_ABSORPTION =
        cfg.global.GLOBAL_DEN_ABSORPTION ||
        DEFAULT_STATE_CONFIG.global.GLOBAL_DEN_ABSORPTION;
    $("i-gden-abs").value = GLOBAL_DEN_ABSORPTION;
    GLOBAL_DEN_REFRACTION =
        cfg.global.GLOBAL_DEN_REFRACTION ||
        DEFAULT_STATE_CONFIG.global.GLOBAL_DEN_REFRACTION;
    $("i-gden-ref").value = GLOBAL_DEN_REFRACTION;

    EXPOSURE = cfg.global.EXPOSURE || DEFAULT_STATE_CONFIG.global.EXPOSURE;
    $("i-exposure").value = EXPOSURE;
    AUTO_EXPOSURE =
        cfg.global.AUTO_EXPOSURE || DEFAULT_STATE_CONFIG.global.AUTO_EXPOSURE;
    $("cb-auto-exposure").checked = AUTO_EXPOSURE;

    $("i-sp").value =
        cfg.global.sunPitch || DEFAULT_STATE_CONFIG.global.sunPitch;
    $("i-sy").value =
        cfg.global.sunYaw || DEFAULT_STATE_CONFIG.global.sunYaw;

    const is3D =
        cfg.IS_3D_MODE !== undefined
            ? cfg.IS_3D_MODE
            : cfg.global.IS_3D_MODE || DEFAULT_STATE_CONFIG.global.IS_3D_MODE;
    VOL_LAYERS =
        cfg.VOL_LAYERS !== undefined
            ? cfg.VOL_LAYERS
            : cfg.global.VOL_LAYERS || DEFAULT_STATE_CONFIG.global.VOL_LAYERS;
    const iVd = $("i-vd");
    if (iVd) iVd.value = VOL_LAYERS;

    IS_3D_MODE = is3D;

    $("i-sp").value =
        cfg.global.sunPitch || DEFAULT_STATE_CONFIG.global.sunPitch;
    $("i-sy").value =
        cfg.global.sunYaw || DEFAULT_STATE_CONFIG.global.sunYaw;

    layers = [];
    layerCounter = 0;

    let layerCfg = cfg.layers || DEFAULT_STATE_CONFIG.layers;

    if (layerCfg.length > 0) {
        BASE_LAYER_CFG.volShadingMode =
            layerCfg[0].volShadingMode || BASE_LAYER_CFG.volShadingMode;
        BASE_LAYER_CFG.volGradientStops =
            layerCfg[0].volGradientStops || DEFAULT_VOL_GRADIENT_STOPS;
        BASE_LAYER_CFG.volGradientBias =
            layerCfg[0].volGradientBias || BASE_LAYER_CFG.volGradientBias;
        BASE_LAYER_CFG.volGradientContrast =
            layerCfg[0].volGradientContrast ||
            BASE_LAYER_CFG.volGradientContrast;
        BASE_LAYER_CFG.pointFalloff =
            layerCfg[0].pointFalloff || BASE_LAYER_CFG.pointFalloff;

        BASE_LAYER_CFG.C = layerCfg[0].C;
        BASE_LAYER_CFG.D = layerCfg[0].D;
        BASE_LAYER_CFG.K = layerCfg[0].K;
    }

    if (is3D) {
        for (let k = 0; k < VOL_LAYERS; k++) {
            layers.push(defL(layerCounter++));
        }
    } else {
        layerCfg.forEach((lCfg) => {
            let newL = defL(layerCounter++);
            Object.assign(newL, lCfg);

            const preset =
                FORMULA_PRESETS[newL.formulaKey] || FORMULA_PRESETS.WAVE;
            newL.C_label = preset.C_label;
            newL.D_label = preset.D_label;
            layers.push(newL);
        });
    }

    emits = (cfg.emits || []).map(e => ({
        ...e,
        id: Date.now() + Math.random(),
        isProbe: e.isProbe || false,
        probeRadius: e.probeRadius || BASE_PROBE_CFG.probeRadius,
        probeSensitivity: e.probeSensitivity || BASE_PROBE_CFG.probeSensitivity,
        controlMode: e.controlMode || "OFF", // NEW
        key: e.key || BASE_EMITTER_CFG.key, // NEW
        isKeyPressed: false, // Reset key state
    }));

    VALVES = (cfg.valves || []).map(v => ({
        ...v,
        id: Date.now() + Math.random(),
        isKeyPressed: false,
    }));

    if (cfg.camera) {
        rad = cfg.camera.rad || DEFAULT_STATE_CONFIG.camera.rad;
        theta = cfg.camera.theta || DEFAULT_STATE_CONFIG.camera.theta;
        phi = cfg.camera.phi || DEFAULT_STATE_CONFIG.camera.phi;
        updCam();
    }

    initData();

    if (cfg.layers && Array.isArray(cfg.layers) && !is3D) {
        cfg.layers.forEach((lCfg, i) => {
            if (lCfg.den && Array.isArray(lCfg.den) && den[i]) {
                if (lCfg.den.length === GRID * GRID) {
                    den[i].set(lCfg.den);
                }
            }
        });
    }

    if (cfg.globalDen && Array.isArray(cfg.globalDen)) {
        GLOBAL_DEN = new Float32Array(cfg.globalDen);
    } else {
        GLOBAL_DEN.fill(0);
    }

    GLOBAL_COUPLING_LINKS = cfg.globalCoupling || [];

    GLOBAL_COUPLING_LINKS = GLOBAL_COUPLING_LINKS.map((link) => ({
        ...link,
        type: link.type || "APPLY_FORCE",
        targetProperty: link.targetProperty || "AMPLITUDE",
    }));

    updateSimControls();

    if (cfg.initialDensity) {
        currentSDFParams = Object.assign(
            currentSDFParams,
            cfg.initialDensity,
        );

        placeShape(
            GRID / 2,
            GRID / 2,
            IS_3D_MODE ? 0 : layers.findIndex((l) => l.intr),
        );
    }

    updateUI();

    $("i-sp").oninput();
    $("l-gap").innerText = GAP;
    $("l-z").innerText = ZSC.toFixed(1);
    $("l-vism").innerText = `${visMin.toFixed(2)} - ${visMax.toFixed(2)}`;

    selectedEmitterId = null;
    selectedValveId = null;
    updateEmitterInspector();
    updateValveInspector();

    resetSimulationAndState();
    IS_PAUSED = false;
}

function initData(keepGlobalDen = false) { 
    GRID = +$("i-res").value;
    u = layers.map(() => new Float32Array(GRID * GRID));
    u_prev = layers.map(() => new Float32Array(GRID * GRID));
    u_aux = layers.map(() => new Float32Array(GRID * GRID));
    den = layers.map(() => new Float32Array(GRID * GRID));
    layerDensityModulations = layers.map(
      () => new Float32Array(GRID * GRID),
    );
    layerCouplingContributions = layers.map(
      () => new Float32Array(GRID * GRID),
    );

    if (!keepGlobalDen || GLOBAL_DEN.length !== GRID * GRID) { 
      GLOBAL_DEN = new Float32Array(GRID * GRID);
    }
    syncM();
    $("l-res").innerText = GRID;
}

      function resetSimulationAndState() {
        IS_PAUSED = true;
        TIME = 0;
        PROBE_HISTORY = [];
        emits = emits.filter((e) => e.type !== "EMITTER_LINE_DRAG");
        VALVES.forEach((v) => v.isKeyPressed = false);
        u.forEach((arr) => arr.fill(0));
        u_prev.forEach((arr) => arr.fill(0));
        MAX_WAVE_ABS = 0.0;
        selectedEmitterId = null;
        selectedValveId = null;
        updateEmitterInspector();
        updateValveInspector();
        syncE();
        stopAudio();
        stopRealtimeAudio();
      }
function updateEmitterInspector() {
    const menu = $("emit-menu");
    const valveMenu = $("valve-menu");
    const probeControls = $("probe-controls-group");
    const emitterControls = $("emitter-controls-group");
    const toggleBtn = $("em-probe-toggle");
    const audioBtn = $("em-audio-btn");
    
    if (!selectedEmitterId) {
      menu.style.display = "none";
      editEmitId = null;
      return;
    }
    
    const em = emits.find((x) => x.id === selectedEmitterId);
    if (!em) {
      selectedEmitterId = null;
      menu.style.display = "none";
      editEmitId = null;
      return;
    }
    
    editEmitId = em.id;
    menu.style.display = "block";
    valveMenu.style.display = "none";
    selectedValveId = null;

    const isProbe = em.isProbe || false;
    
    // Get existing control elements (which are already in the HTML)
    const emControlMode = document.getElementById("em-control-mode");
    const emKeySelectDiv = document.getElementById("em-key-select-div");
    const emKeyInput = document.getElementById("em-key");
    const emStateLabel = document.getElementById("em-state");
    
    // Ensure all elements exist before proceeding with updates
    if (!emControlMode || !emKeySelectDiv || !emKeyInput || !emStateLabel) {
        console.error("Missing emitter control UI elements in HTML.");
        return;
    }


    if (isProbe) {
        probeControls.style.display = 'block';
        emitterControls.style.display = 'none';
        toggleBtn.textContent = 'Set as Emitter';
        toggleBtn.classList.remove('probe-active');
        audioBtn.style.display = 'block';
        
        if (ACTIVE_PROBE_ID !== selectedEmitterId) {
            ACTIVE_PROBE_ID = selectedEmitterId;
            PROBE_HISTORY = [];
            $("probe-menu").style.display = 'none';
            stopAudio();
            stopRealtimeAudio();
        }
        
        $("pr-rad").value = em.probeRadius;
        $("pr-rad-v").innerText = em.probeRadius;
        $("pr-sens").value = em.probeSensitivity;
        $("pr-sens-v").innerText = em.probeSensitivity.toFixed(2);
        
        EV("pr-rad", "input", (e) => {
            const val = +e.target.value;
            em.probeRadius = val;
            $("pr-rad-v").innerText = val;
            syncE();
        });
        EV("pr-sens", "input", (e) => {
            const val = +e.target.value;
            em.probeSensitivity = val;
            $("pr-sens-v").innerText = val.toFixed(2);
            if (IS_REALTIME_AUDIO && REALTIME_GAIN && AUDIO_CONTEXT) {
                 REALTIME_GAIN.gain.setValueAtTime(0.5 * val, AUDIO_CONTEXT.currentTime);
            }
        });

    } else {
        probeControls.style.display = 'none';
        emitterControls.style.display = 'block';
        toggleBtn.textContent = 'Set as Probe';
        toggleBtn.classList.add('probe-active');
        audioBtn.style.display = 'none';
        
        if (ACTIVE_PROBE_ID === selectedEmitterId) {
            ACTIVE_PROBE_ID = null;
            $("probe-menu").style.display = 'none';
            stopAudio();
            stopRealtimeAudio();
        }
        
        // Emitter Control Modes (Configuration logic)
        emControlMode.value = em.controlMode;
        emKeyInput.value = em.key || BASE_EMITTER_CFG.key;

        const updateKeyVisibility = () => {
            emKeySelectDiv.style.display = emControlMode.value === "KEY_ACTIVATED" ? 'block' : 'none';
        };
        updateKeyVisibility();

        // Remove old listeners to prevent duplicates
        emControlMode.onchange = null;
        emKeyInput.onkeydown = null;
        
        emControlMode.onchange = (e) => {
            em.controlMode = e.target.value;
            updateKeyVisibility();
            syncE();
            updateEmitterMenuInfo();
        };

        emKeyInput.onkeydown = (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (e.code) {
                em.key = e.code;
                emKeyInput.value = e.code;
                emKeyInput.blur();
            }
        };

        // Update other emitter controls
        $("em-shp").value = em.shp;
        $("em-geo").value = em.geo || "POINT";
        $("em-st").value = em.st;
        $("i-em-rt").value = em.rt;
        $("i-em-of").value = em.off;
        $("em-st-v").innerText = em.st.toFixed(1);
        $("em-rt-v").innerText = em.rt;
        $("em-of-v").innerText = em.off;
    }
    
    const prRad = $("pr-rad");
    if (prRad) prRad.classList.add("custom-drag-slider");
    const prSens = $("pr-sens");
    if (prSens) prSens.classList.add("custom-drag-slider");
    
    syncE();
    updateProbeMenuInfo();
    updateEmitterMenuInfo();
}

    function updateEmitterMenuInfo() {
    const em = emits.find((x) => x.id === selectedEmitterId);
    if (em && em.controlMode === "KEY_ACTIVATED") {
        const emStateLabel = document.getElementById("em-state");
        const emStateDiv = emStateLabel ? emStateLabel.closest('label') : null;
        if (emStateLabel) {
            emStateLabel.innerText = em.isKeyPressed ? 'ACTIVE' : 'INACTIVE';
            emStateLabel.style.color = em.isKeyPressed ? 'var(--color-active)' : '#ccc';
        }
        if (emStateDiv) {
            emStateDiv.style.color = em.isKeyPressed ? 'var(--color-active)' : '#ccc';
        }
    }
}
    function updateValveInspector() {
        const menu = $("valve-menu");
        const emitMenu = $("emit-menu");
        
        if (!selectedValveId) {
            menu.style.display = "none";
            editValveId = null;
            return;
        }
        
        const valve = VALVES.find((x) => x.id === selectedValveId);
        if (!valve) {
            selectedValveId = null;
            menu.style.display = "none";
            editValveId = null;
            return;
        }

        editValveId = valve.id;
        menu.style.display = "block";
        emitMenu.style.display = "none";
        selectedEmitterId = null;

        $("v-key").value = valve.key;
        $("v-rad").value = valve.radius;
        $("v-closed").value = valve.closedDensity;
        $("v-open").value = valve.openDensity;
        
        $("v-rad-v").innerText = valve.radius;
        $("v-closed-v").innerText = valve.closedDensity.toFixed(2);
        $("v-open-v").innerText = valve.openDensity.toFixed(2);
        
        $("v-state").innerText = valve.isKeyPressed ? 'OPEN' : 'CLOSED';
        $("v-state").style.color = valve.isKeyPressed ? 'var(--color-valve-open)' : 'var(--color-text)';

        EV("v-rad", "input", (e) => {
            const val = +e.target.value;
            valve.radius = val;
            $("v-rad-v").innerText = val;
            syncE();
        });
        EV("v-closed", "input", (e) => {
            const val = +e.target.value;
            valve.closedDensity = val;
            $("v-closed-v").innerText = val.toFixed(2);
        });
        EV("v-open", "input", (e) => {
            const val = +e.target.value;
            valve.openDensity = val;
            $("v-open-v").innerText = val.toFixed(2);
        });
        
        const vRad = $("v-rad");
        if (vRad) vRad.classList.add("custom-drag-slider");
        const vClosed = $("v-closed");
        if (vClosed) vClosed.classList.add("custom-drag-slider");
        const vOpen = $("v-open");
        if (vOpen) vOpen.classList.add("custom-drag-slider");
        
        $("v-key").onkeydown = (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (e.code) {
                valve.key = e.code;
                $("v-key").value = e.code;
                $("v-key").blur();
            }
        };

        syncE();
    }
      
      function updateProbeMenuInfo() {
          const em = emits.find((x) => x.id === ACTIVE_PROBE_ID);
          const infoDiv = $('probe-info');
          
          if (!em) {
              infoDiv.innerHTML = 'Select a probe to begin signal analysis.';
              return;
          }
          
          const maxAbs = PROBE_HISTORY.reduce((max, val) => Math.max(max, Math.abs(val)), 0);
          const maxValClamped = Math.max(0.001, maxAbs).toFixed(3);
          const currentVal = PROBE_HISTORY.length > 0 ? PROBE_HISTORY[PROBE_HISTORY.length - 1].toFixed(3) : '0.000';
          
          infoDiv.innerHTML = `
              <b>Probe ID:</b> ${em.id}<br>
              <b>Layer:</b> ${em.lIdx + 1}<br>
              <b>Recorded Samples:</b> ${PROBE_HISTORY.length} / ${PROBE_HISTORY_LENGTH}<br>
              <b>Current Signal:</b> ${currentVal}<br>
              <b>Max Signal Amplitude:</b> ${maxValClamped}
          `;
      }
      
      function updateValveMenuInfo() {
          const valve = VALVES.find((x) => x.id === selectedValveId);
          if (valve) {
              $("v-state").innerText = valve.isKeyPressed ? 'OPEN' : 'CLOSED';
              $("v-state").style.color = valve.isKeyPressed ? 'var(--color-valve-open)' : 'var(--color-text)';
          }
      }
      
      function updateMarkers(el) {
          const startMarkerEl = $('probe-start-marker');
          const endMarkerEl = $('probe-end-marker');
          const sampleRangeLabel = $('l-sample-range');

          LOOP_START_IDX = +startMarkerEl.value;
          LOOP_END_IDX = +endMarkerEl.value;
          
          const historyLen = PROBE_HISTORY_LENGTH || 1;

          if (LOOP_START_IDX > LOOP_END_IDX) {
              if (el === startMarkerEl) {
                  LOOP_END_IDX = LOOP_START_IDX;
                  endMarkerEl.value = LOOP_END_IDX;
              } else {
                  LOOP_START_IDX = LOOP_END_IDX;
                  startMarkerEl.value = LOOP_START_IDX;
              }
          }
          
          const totalLength = PROBE_HISTORY_LENGTH;
          const startPct = (LOOP_START_IDX / totalLength) * 100;
          const endPct = (LOOP_END_IDX / totalLength) * 100;
          
          const root = document.documentElement;
          root.style.setProperty('--marker-start', `${startPct}%`);
          root.style.setProperty('--marker-end', `${endPct}%`);
          
          sampleRangeLabel.innerText = `${LOOP_START_IDX} - ${LOOP_END_IDX} (${LOOP_END_IDX - LOOP_START_IDX} samples)`;

          const maxAbs = PROBE_HISTORY.reduce((max, val) => Math.max(max, Math.abs(val)), 0);
          renderProbeGraph(PROBE_HISTORY, maxAbs);
          
          if (IS_AUDIO_PLAYING) {
              stopAudio();
          }
      }

      function toggleEmitterProbe() {
          const em = emits.find((x) => x.id === selectedEmitterId);
          if (em) {
              em.isProbe = !em.isProbe;
              em.probeRadius = em.probeRadius || BASE_PROBE_CFG.probeRadius;
              em.probeSensitivity = em.probeSensitivity || BASE_PROBE_CFG.probeSensitivity;
              
              if (em.isProbe) {
                  em.geo = 'POINT';
                  em.st = 0;
                  em.shp = 'STATIC';
                  stopAudio();
              } else {
                  if (ACTIVE_PROBE_ID === selectedEmitterId) {
                      ACTIVE_PROBE_ID = null;
                      $("probe-menu").style.display = 'none';
                      stopAudio();
                      stopRealtimeAudio();
                  }
              }
              
              updateEmitterInspector();
          }
      }

      function deleteSelectedEmitter() {
        if (selectedEmitterId) {
          const idx = emits.findIndex((e) => e.id === selectedEmitterId);
          if (idx !== -1) {
            emits.splice(idx, 1);
            if (ACTIVE_PROBE_ID === selectedEmitterId) {
                ACTIVE_PROBE_ID = null;
                $("probe-menu").style.display = 'none';
                stopAudio();
                stopRealtimeAudio();
            }
            selectedEmitterId = null;
            updateEmitterInspector();
            syncE();
          }
        }
      }

function deleteSelectedValve() {
    if (selectedValveId) {
      const idx = VALVES.findIndex((v) => v.id === selectedValveId);
      if (idx !== -1) {
        VALVES.splice(idx, 1);
        selectedValveId = null;
        updateValveInspector();
        syncE();
        syncM();
      }
    }
}


      function renderVolGradientControls() {
        const d = $("vol-gradient-stops");
        d.innerHTML = "";
        const stops = BASE_LAYER_CFG.volGradientStops;
        const l = BASE_LAYER_CFG;

        window.volAddStop = function () {
          stops.length < MAX_GRADIENT_STOPS
            ? stops.push([200, 200, 200])
            : null;
          updTr();
          updateUI();
        };
        window.volRemoveStop = function (idx) {
          stops.length > 1 ? stops.splice(idx, 1) : null;
          updTr();
          updateUI();
        };

        stops.forEach((stop, index) => {
          var colorInputId = `vol_color_stop_${index}`;
          var b = document.createElement("div");
          b.className = "color-picker-row";
          b.innerHTML = `<label>Stop ${index}</label><input type="color" id="${colorInputId}" value="${toHex(
            stop,
          )}" oninput="var c=this.value; BASE_LAYER_CFG.volGradientStops[${index}]=hexToRgb(c); syncM();">
                    ${
                      stops.length > 1
                        ? `<button onclick="window.volRemoveStop(${index})">-</button>`
                        : ""
                    }</div>`;
	d.appendChild(b);
        });

        $("vol-shade-select").value = l.volShadingMode;
        $("i-vol-gb").value = l.volGradientBias;
        $("l-vol-gb").innerText = l.volGradientBias.toFixed(2);
        $("i-vol-gc").value = l.volGradientContrast;
        $("l-vol-gc").innerText = l.volGradientContrast.toFixed(1);
        $("i-pf").value = l.pointFalloff;
        $("l-pf").innerText = l.pointFalloff.toFixed(2);

        $("btn-add-vol-stop").onclick = window.volAddStop;

        const iVolGb = $("i-vol-gb");
        if (iVolGb) iVolGb.classList.add("custom-drag-slider");
        const iVolGc = $("i-vol-gc");
        if (iVolGc) iVolGc.classList.add("custom-drag-slider");
        const iPf = $("i-pf");
        if (iPf) iPf.classList.add("custom-drag-slider");

        EV("vol-shade-select", "change", (e) => {
          BASE_LAYER_CFG.volShadingMode = e.target.value;
          syncM();
        });

        EV("i-vol-gb", "input", (e) => {
          BASE_LAYER_CFG.volGradientBias = parseFloat(e.target.value);
          $("l-vol-gb").innerText = BASE_LAYER_CFG.volGradientBias.toFixed(2);
          syncM();
        });

        EV("i-vol-gc", "input", (e) => {
          BASE_LAYER_CFG.volGradientContrast = parseFloat(e.target.value);
          $("l-vol-gc").innerText =
            BASE_LAYER_CFG.volGradientContrast.toFixed(1);
          syncM();
        });

        EV("i-pf", "input", (e) => {
          BASE_LAYER_CFG.pointFalloff = parseFloat(e.target.value);
          $("l-pf").innerText = BASE_LAYER_CFG.pointFalloff.toFixed(2);
          layers.forEach((l) => (l.pointFalloff = BASE_LAYER_CFG.pointFalloff));
          syncM();
        });
	setupCustomSliderDrag();
      }

      function renderDynamicBrushControls() {
        const d = $("dynamic-brush-controls");
        let content = "";

        if (brush !== "EMITTER_PLACE" && brush !== "VALVE_PLACE" && brush !== "SDF_PLACE") {
          content += `<label>Brush Radius: <span id="l-rad" class="value-label">${mRad}</span></label><input type="range" id="i-rad" min="1" max="50" value="${mRad}"><label>Brush Hardness (Falloff Edge): <span id="l-hnd" class="value-label">${brushHnd.toFixed(
            1,
          )}</span></label><input type="range" id="i-hnd" min="0.0" max="1.0" value="${brushHnd}" step="0.1">`;
        }
        
        if (brush === "VALVE_PLACE") {
            const valveControls = `
                <h4 style="margin-top: 10px;">Valve Creation Defaults</h4>
                <label>Default Radius: <span id="l-vrad-def" class="value-label">${BASE_VALVE_CFG.radius}</span></label>
                <input type="range" id="i-vrad-def" min="1" max="30" value="${BASE_VALVE_CFG.radius}" step="1">
                <label>Default Key: <span id="l-vkey-def" class="value-label">${BASE_VALVE_CFG.key}</span></label>
                <label>Closed Density: <span id="l-vclosed-def" class="value-label">${BASE_VALVE_CFG.closedDensity.toFixed(2)}</span></label>
                <input type="range" id="i-vclosed-def" min="0.0" max="1.0" value="${BASE_VALVE_CFG.closedDensity}" step="0.01">
                <label>Open Density: <span id="l-vopen-def" class="value-label">${BASE_VALVE_CFG.openDensity.toFixed(2)}</span></label>
                <input type="range" id="i-vopen-def" min="0.0" max="1.0" value="${BASE_VALVE_CFG.openDensity}" step="0.01">
            `;
            content += valveControls;
        }

        if (brush === "DISTURBANCE") {
          const impulseControls = `<h4 style="margin-top: 10px;">Impulse Behavior</h4><label>Impulse Magnitude: <span id="l-mag" class="value-label">${IMPULSE_MAGNITUDE.toFixed(
            1,
          )}</span></label><input type="range" id="i-mag" min="0.1" max="15.0" value="${IMPULSE_MAGNITUDE}" step="0.1"><label>Wavelength / Duration: <span id="l-wave-len" class="value-label">${IMPULSE_WAVELENGTH}</span></label><input type="range" id="i-wave-len" min="10" max="200" value="${IMPULSE_WAVELENGTH}"><div class="row"><label>Type</label><select id="i-type" style="width:100%;"><option value="PULSE" ${
            !IS_IMPULSE_HOLD ? "selected" : ""
          }>Pulse (Transient)</option><option value="HOLD" ${
            IS_IMPULSE_HOLD ? "selected" : ""
          }>Hold (Continuous)</option></select></div><div class="row" style="margin-top: 4px;"><label>Waveform</label><select id="i-wave-shape" style="width:100%;"><option value="CONSTANT" ${
            IMPULSE_WAVE_TYPE === "CONSTANT" ? "selected" : ""
          }>Constant Pulse</option><option value="SINE" ${
            IMPULSE_WAVE_TYPE === "SINE" ? "selected" : ""
          }>Sine Pulse</option><option value="COSINE" ${
            IMPULSE_WAVE_TYPE === "COSINE" ? "selected" : ""
          }>Cosine Wave</option><option value="SQUARE" ${
            IMPULSE_WAVE_TYPE === "SQUARE" ? "selected" : ""
          }>Square Pulse</option><option value="SAW" ${
            IMPULSE_WAVE_TYPE === "SAW" ? "selected" : ""
          }>Sawtooth Pulse</option></select></div><div class="row" style="margin-top: 4px;"><label>Shape</label><select id="i-shape" style="width:100%;"><option value="GAUSSIAN" ${
            IMPULSE_SHAPE === "GAUSSIAN" ? "selected" : ""
          }>Gaussian (Soft)</option><option value="SQUARE" ${
            IMPULSE_SHAPE === "SQUARE" ? "selected" : ""
          }>Square (Hard Edge)</option></select></div>`;
          content += impulseControls;
        } else if (brush === "DENSITY_PAINT") {
          const densityControls = `
                    <h4 style="margin-top: 10px;">Density Paint Controls</h4>
                    <label>Paint Density Val: <span id="l-pv" class="value-label">${mVal.toFixed(
                      1,
                    )}</span></label>
                    <input type="range" id="i-pv" min="0" max="1" step="0.1" value="${mVal}">
                    
                    <label>Density Flow Rate (Softness): <span id="l-flow" class="value-label">${DEN_FLOW_RATE.toFixed(
                      2,
                    )}</span></label>
                    <input type="range" id="i-flow" min="0.01" max="1.0" step="0.01" value="${DEN_FLOW_RATE}">

                    <div class="row" style="margin-top: 4px;">
                        <label>Density Brush Mode</label>
                        <select id="i-den-mode" style="width:100%;">
                            <option value="REPLACE" ${
                              DEN_BRUSH_MODE === "REPLACE" ? "selected" : ""
                            }>Replace/Blend</option>
                            <option value="ADD" ${
                              DEN_BRUSH_MODE === "ADD" ? "selected" : ""
                            }>Add Only</option>
                            <option value="SUBTRACT" ${
                              DEN_BRUSH_MODE === "SUBTRACT" ? "selected" : ""
                            }>Subtract Only</option>
                        </select>
                    </div>`;
          content += densityControls;
        }

        d.innerHTML = content;

        const iRad = $("i-rad");
        if (iRad) {
          iRad.classList.add("custom-drag-slider");
          iRad.oninput = (e) => {
            mRad = +e.target.value;
            $("l-rad").innerText = mRad;
          };
        }
        const iHnd = $("i-hnd");
        if (iHnd) {
          iHnd.classList.add("custom-drag-slider");
          iHnd.oninput = (e) => {
            brushHnd = +e.target.value;
            $("l-hnd").innerText = brushHnd.toFixed(1);
          };
        }

        const iMag = $("i-mag");
        if (iMag) {
          iMag.classList.add("custom-drag-slider");
          iMag.oninput = (e) => {
            IMPULSE_MAGNITUDE = +e.target.value;
            $("l-mag").innerText = IMPULSE_MAGNITUDE.toFixed(1);
          };
          $("i-type").onchange = (e) => {
            IS_IMPULSE_HOLD = e.target.value === "HOLD";
          };
          $("i-shape").onchange = (e) => {
            IMPULSE_SHAPE = e.target.value;
          };
          $("i-wave-shape").onchange = (e) => {
            IMPULSE_WAVE_TYPE = e.target.value;
          };
          $("i-wave-len").oninput = (e) => {
            IMPULSE_WAVELENGTH = +e.target.value;
            $("l-wave-len").innerText = IMPULSE_WAVELENGTH;
          };
          $("i-wave-len").classList.add("custom-drag-slider");
        }

        const iPv = $("i-pv");
        if (iPv) {
          iPv.classList.add("custom-drag-slider");
          iPv.oninput = (e) => {
            mVal = +e.target.value;
            $("l-pv").innerText = mVal.toFixed(1);
          };
        }
        const iFlow = $("i-flow");
        if (iFlow) {
          iFlow.classList.add("custom-drag-slider");
          iFlow.oninput = (e) => {
            DEN_FLOW_RATE = +e.target.value;
            $("l-flow").innerText = DEN_FLOW_RATE.toFixed(2);
          };
          $("i-den-mode").onchange = (e) => {
            DEN_BRUSH_MODE = e.target.value;
          };
        }
        
        const iVradDef = $("i-vrad-def");
        if (iVradDef) {
            iVradDef.classList.add("custom-drag-slider");
            iVradDef.oninput = (e) => {
                BASE_VALVE_CFG.radius = +e.target.value;
                $("l-vrad-def").innerText = BASE_VALVE_CFG.radius;
            };
        }
        const iVclosedDef = $("i-vclosed-def");
        if (iVclosedDef) {
            iVclosedDef.classList.add("custom-drag-slider");
            iVclosedDef.oninput = (e) => {
                BASE_VALVE_CFG.closedDensity = +e.target.value;
                $("l-vclosed-def").innerText = BASE_VALVE_CFG.closedDensity.toFixed(2);
            };
        }
        const iVopenDef = $("i-vopen-def");
        if (iVopenDef) {
            iVopenDef.classList.add("custom-drag-slider");
            iVopenDef.oninput = (e) => {
                BASE_VALVE_CFG.openDensity = +e.target.value;
                $("l-vopen-def").innerText = BASE_VALVE_CFG.openDensity.toFixed(2);
            };
        }
      }

      function renderCouplingMatrixUI() {
        const container = $("coupling-links-container");
        container.innerHTML = "";

        if (layers.length < 2) {
          container.innerHTML =
            '<p style="text-align:center; color:#888;">Add at least two layers to enable coupling.</p>';
          return;
        }

        const layerOptions = layers
          .map((l, i) => {
            const name = l.name
              .replace(/&/g, "&amp;")
              .replace(/</g, "&lt;")
              .replace(/>/g, "&gt;")
              .replace(/"/g, "&quot;");
            const optionText = `Layer ${i + 1} (${name})`;
            return `<option value="${i}">${optionText}</option>`;
          })
          .join("");

        const couplingTypeOptions = Object.entries(COUPLING_TYPES)
          .map(([key, value]) => `<option value="${key}">${value}</option>`)
          .join("");

        const targetPropertyOptions = [
          { value: "AMPLITUDE", label: "Amplitude (Wave Value)" },
          { value: "VELOCITY", label: "Velocity (Wave Change)" },
        ]
          .map((opt) => `<option value="${opt.value}">${opt.label}</option>`)
          .join("");

        GLOBAL_COUPLING_LINKS.forEach((link, index) => {
          const linkDiv = document.createElement("div");
          linkDiv.className = "coupling-link";

          const rateText = link.rate ? link.rate.toFixed(4) : "0.0000";

          const isModulateDensity = link.type === "MODULATE_DENSITY";
          const isSymmetricExchange = link.type === "ENERGY_EXCHANGE";
          const isApplyForce = link.type === "APPLY_FORCE";

          const srcLabel = isSymmetricExchange ? "Layer A" : "Source Layer";
          const tgtLabel = isSymmetricExchange ? "Layer B" : "Target Layer";

          linkDiv.innerHTML = `
                    <div class="row" style="justify-content: space-between;">
                        <b>Link ${index + 1} (${
                          COUPLING_TYPES[link.type] || "Unknown"
                        })</b>
                        <button onclick="deleteCouplingLink(${index})" style="width: 30px; padding: 0 4px; background: var(--color-danger); border-color: #844;">X</button>
                    </div>
                    
                    <label>${srcLabel}</label>
                    <select id="link_src_${index}" onchange="updateCouplingLink(${index}, 'sourceIdx', +this.value)">
                       ${layerOptions}
                    </select>
                    
                    <label style="margin-top: 8px;">Coupling Type</label>
                    <select id="link_type_${index}" onchange="updateCouplingLink(${index}, 'type', this.value)">
                       ${couplingTypeOptions}
                    </select>

                    <div id="target-layer-group-${index}" style="display:${
                      isSymmetricExchange ? "none" : "block"
                    };">
                        <label>${tgtLabel}</label>
                        <select id="link_tgt_${index}" onchange="updateCouplingLink(${index}, 'targetIdx', +this.value)">
                           ${layerOptions}
                        </select>
                    </div>
                    
                    <label>Coupling Rate: <span id="l_rate_${index}" class="value-label">${rateText}</span></label>
                    <input type="range" min="0" max="1.0" step="0.0001" value="${
                      link.rate
                    }" 
                           data-link-index="${index}" data-link-property="rate"
                           class="custom-drag-slider coupling-rate-slider">

                    <div id="target-prop-group-${index}" style="display:${
                      isApplyForce ? "block" : "none"
                    };">
                        <label>Source Value (for Force)</label>
                        <select onchange="updateCouplingLink(${index}, 'targetProperty', this.value)">
                            ${targetPropertyOptions}
                        </select>
                    </div>
                `;

          linkDiv.querySelector(`#link_src_${index}`).value = link.sourceIdx;

          if (linkDiv.querySelector(`#link_tgt_${index}`)) {
            linkDiv.querySelector(`#link_tgt_${index}`).value = link.targetIdx;
          }

          linkDiv.querySelector(`#link_type_${index}`).value = link.type;

          if (isApplyForce) {
            linkDiv.querySelector(`#target-prop-group-${index} select`).value =
              link.targetProperty;
          }

          container.appendChild(linkDiv);
const rateSlider = linkDiv.querySelector('.coupling-rate-slider');
          if (rateSlider) {
              rateSlider.addEventListener('input', function() {
                  const index = parseInt(this.dataset.linkIndex);
                  updateCouplingLink(index, 'rate', parseFloat(this.value));
              });
          }
        });
        setupCustomSliderDrag();
      }

      function addCouplingLink() {
        if (layers.length < 2) {
          $("err").innerText = "Cannot add link: Need at least two layers.";
          return;
        }

        GLOBAL_COUPLING_LINKS.push({
          sourceIdx: 0,
          targetIdx: Math.min(1, layers.length - 1),
          rate: 0.001,
          type: "ENERGY_EXCHANGE",
          targetProperty: "AMPLITUDE",
        });
        renderCouplingMatrixUI();
      }

      function updateCouplingLink(index, property, value) {
        if (GLOBAL_COUPLING_LINKS[index]) {
          GLOBAL_COUPLING_LINKS[index][property] = value;
        }

        if (
          property === "sourceIdx" ||
          property === "targetIdx" ||
          property === "type"
        ) {
          renderCouplingMatrixUI();

          if (GLOBAL_COUPLING_LINKS[index].type === "ENERGY_EXCHANGE") {
            const src = GLOBAL_COUPLING_LINKS[index].sourceIdx;
            const tgt = GLOBAL_COUPLING_LINKS[index].targetIdx;
            if (src === tgt) {
              GLOBAL_COUPLING_LINKS[index].targetIdx =
                (src + 1) % layers.length;
              renderCouplingMatrixUI();
            }
          }
        } else if (property === "rate") {
          const label = $(`l_rate_${index}`);
          if (label) label.innerText = value.toFixed(4);
        }
      }

      function deleteCouplingLink(index) {
        GLOBAL_COUPLING_LINKS.splice(index, 1);
        renderCouplingMatrixUI();
      }
      
      function updateLayerFormulaParams(layerIndex, key) {
          const l = layers[layerIndex];
          const newPreset = FORMULA_PRESETS[key] || FORMULA_PRESETS.WAVE;
          const cInputId = `i-c-${l.id}`;
          const dInputId = `i-d-${l.id}`;

          l.formulaKey = key;
          l.C = newPreset.defaultC;
          l.D = newPreset.defaultD;
          l.C_label = newPreset.C_label;
          l.D_label = newPreset.D_label;

          const cInput = $(cInputId);
          const dInput = $(dInputId);
          
          if (cInput) {
              cInput.max = newPreset.C_max;
              cInput.value = newPreset.defaultC;
          }
          if (dInput) {
              dInput.max = newPreset.D_max;
              dInput.value = newPreset.defaultD;
          }

          updateLayerListUI();
      }


      function updateLayerListUI() {
        const expansionState = getExpansionState();
        var d = $("layers");
        d.innerHTML = "";

        const is3D = IS_3D_MODE;
        $("layers-group").style.display = is3D ? "none" : "block";

        if (is3D && layers.length > 0) {
          d.innerHTML =
            '<div class="layer-box" style="border-color:var(--color-active); text-align:center; padding:10px;"><b>Volume Mode Active</b><br><small>Physics and Visualization are controlled globally.</small></div>';

          var l = BASE_LAYER_CFG;
          var b = document.createElement("div");
          b.className = "layer-box";
          b.style.borderColor = "var(--color-active)";
          b.innerHTML = `<div class="row"><b>Global Volume Params</b></div><label>Speed (C)</label><input type="range" id="i-sim-c" min="0.05" max="0.5" step="0.01" value="${l.C}"><label>Damp (D)</label><input type="range" id="i-sim-d" min="0" max="0.1" step="0.001" value="${l.D}"><div class="row"><button onclick="clearSimulation();">Reset Waves</button><button onclick="den.forEach(x=>x.fill(0)); syncM();">Reset Density</button></div>`;
          d.appendChild(b);

          const iSimC = $("i-sim-c");
          if (iSimC) {
            iSimC.classList.add("custom-drag-slider");
            iSimC.oninput = function () {
              BASE_LAYER_CFG.C = +this.value;
            };
          }
          const iSimD = $("i-sim-d");
          if (iSimD) {
            iSimD.classList.add("custom-drag-slider");
            iSimD.oninput = function () {
              BASE_LAYER_CFG.D = +this.value;
            };
          }
        } else if (!is3D) {
          layers.forEach((l, i) => {
            window[`resetDen_${i}`] = function () {
              den[i].fill(0);
              syncM();
            };
            window[`addStop_${i}`] = function () {
              l.gradientStops.length < MAX_GRADIENT_STOPS
                ? l.gradientStops.push([200, 200, 200])
                : null;
              syncM();
              updateLayerListUI();
            };
            window[`removeStop_${i}`] = function (idx) {
              l.gradientStops.length > 1
                ? l.gradientStops.splice(idx, 1)
                : null;
              syncM();
              updateLayerListUI();
            };
            window[`updateLayerBorder_${i}`] = function (hex) {
              $(`layer_box_${l.id}`).style.borderColor = hex;
            };

            const formulaKey = l.formulaKey || "WAVE";
            const preset = FORMULA_PRESETS[formulaKey] || FORMULA_PRESETS.WAVE;
            const cLabel = l.C_label || preset.C_label;
            const dLabel = l.D_label || preset.D_label;

            var b = document.createElement("div");
            b.className = "layer-box layer-controls";
            b.id = `layer_box_${l.id}`;
            b.style.borderColor = `rgb(${l.gradientStops[0].join(",")})`;
            var gradientControlsHtml = `<h4 style="border-bottom:none; margin-top: 5px;">Gradient Stops (${l.gradientStops.length}/${MAX_GRADIENT_STOPS})</h4>`;
            l.gradientStops.forEach((stop, index) => {
              var colorInputId = `color_stop_${l.id}_${index}`;
              gradientControlsHtml += `<div class="color-picker-row"><label>Stop ${index}</label><input type="color" id="${colorInputId}" value="${toHex(
                stop,
              )}" oninput="var c=this.value; layers[${i}].gradientStops[${index}]=hexToRgb(c); window.updateLayerBorder_${i}(c); syncM();">
                    ${
                      l.gradientStops.length > 1
                        ? `<button onclick="window.removeStop_${i}(${index})">-</button>`
                        : ""
                    }</div>`;
            });
            if (l.gradientStops.length < MAX_GRADIENT_STOPS) {
             gradientControlsHtml += `<div style="margin-top: 4px;"><button onclick="window.addStop_${i}()">+ Add Stop</button></div>`;
            }

            var shadingSelectId = `shade_${l.id}`;
            var visModeSelectId = `vis_${l.id}`;

            const formulaSelectHtml = `<label>Simulation Model</label><select id="formula_select_${
              l.id
            }" onchange="updateLayerFormulaParams(${i}, this.value)">${Object.keys(
              FORMULA_PRESETS,
            )
              .map(
                (key) =>
                  `<option value="${key}" ${
                    formulaKey === key ? "selected" : ""
                  }>${FORMULA_PRESETS[key].name}</option>`,
              )
              .join("")}</select>`;

            const cInputId = `i-c-${l.id}`;
            const dInputId = `i-d-${l.id}`;
            const kInputId = `i-k-${l.id}`;

            const pointSizeControls = `<div id="point_size_controls_${l.id}" style="margin-top: 8px; display: ${
              l.visMode === "POINTS" ? "block" : "none"
            };">
                        <label>Point Base Size: <span id="l-psz_${
                          l.id
                        }" class="value-label">${l.pointSize.toFixed(1)}</span></label>
                        <input type="range" id="i-psz-${
                          l.id
                        }" min="0.1" max="20.0" step="0.1" value="${
                          l.pointSize
                        }" oninput="layers[${i}].pointSize = parseFloat(this.value); document.getElementById('l-psz_${
                          l.id
                        }').innerText = this.value; syncM();">
                        <label>Point Scale Factor: <span id="l-psc_${
                          l.id
                        }" class="value-label">${l.pointScaleFactor.toFixed(
                          1,
                        )}</span></label>
                        <input type="range" id="i-psc-${
                          l.id
                        }" min="0.0" max="10.0" step="0.1" value="${
                          l.pointScaleFactor
                        }" oninput="layers[${i}].pointScaleFactor = parseFloat(this.value); document.getElementById('l-psc_${
                          l.id
                        }').innerText = this.value; syncM();">
                        <label>Point Falloff: <span id="l-pf_${
                          l.id
                        }" class="value-label">${l.pointFalloff.toFixed(
                          2,
                        )}</span></label>
                        <input type="range" id="i-pf-${
                          l.id
                        }" min="0.0" max="1.0" step="0.01" value="${
                          l.pointFalloff
                        }" oninput="layers[${i}].pointFalloff = parseFloat(this.value); document.getElementById('l-pf_${
                          l.id
                        }').innerText = this.value; syncM();">
                    </div>`;

            const escapedName = l.name
              .replace(/&/g, "&amp;")
              .replace(/</g, "&lt;")
              .replace(/>/g, "&gt;")
              .replace(/"/g, "&quot;");

            b.innerHTML = `<div class="row"><b>${escapedName}</b><input type="checkbox" id="layer_vis_checkbox_${l.id}" ${
              l.vis ? "checked" : ""
            } onchange="layers[${i}].vis=this.checked; updateLayerParamUI(${i}, 'vis');"><label for="layer_vis_checkbox_${
              l.id
            }" style="margin-right:8px; width: auto;">Vis</label><input type="checkbox" id="layer_intr_checkbox_${
              l.id
            }" ${
              l.intr ? "checked" : ""
            } onchange="layers[${i}].intr=this.checked; updateLayerParamUI(${i}, 'intr');"><label for="layer_intr_checkbox_${
              l.id
            }" style="width: auto;">Int</label></div><div class="expandable-header" data-target="layer-sim-controls-${
              l.id
            }">Simulation Parameters <span class="expand-arrow">&#x25B8;</span></div><div id="layer-sim-controls-${
              l.id
            }" class="expandable-content">${formulaSelectHtml}<div id="sim_controls_${
              l.id
            }"><label><b>${cLabel}</b> (<span id="l-c-${l.id}" class="value-label">${l.C.toFixed(
              3,
            )}</span>)</label><input type="range" id="${cInputId}" min="0.01" max="${
              preset.C_max
            }" step="0.01" value="${l.C}"><label><b>${dLabel}</b> (<span id="l-d-${
              l.id
            }" class="value-label">${l.D.toFixed(
              3,
            )}</span>)</label><input type="range" id="${dInputId}" min="0" max="${
              preset.D_max
            }" step="0.001" value="${l.D}"></div><label>Vertical/Legacy Coupling (K) (<span id="l-k-${
              l.id
            }" class="value-label">${l.K.toFixed(
              3,
            )}</span>)</label><input type="range" id="${kInputId}" min="0" max="0.1" step="0.005" value="${
              l.K
            }"><div class="row"><label>Bnd</label><select onchange="layers[${i}].bnd=this.value;"><option value="FIXED" ${
              l.bnd === "FIXED" ? "selected" : ""
            }>FIXED (Wall)</option><option value="ABSORBING" ${
              l.bnd === "ABSORBING" ? "selected" : ""
            }>ABSORBING (Open)</option></select></div><div class="row"><button onclick="u[${i}].fill(0); u_prev[${i}].fill(0); syncM();">Rst Wav</button><button onclick="window.resetDen_${i}()">Rst Den</button></div></div><div class="expandable-header" data-target="layer-vis-controls-${
              l.id
            }">Visualization & Styling <span class="expand-arrow">&#x25B8;</span></div><div id="layer-vis-controls-${
              l.id
            }" class="expandable-content">${gradientControlsHtml}<div class="row"><label>Vis Mode</label><select id="${visModeSelectId}" onchange="layers[${i}].visMode=this.value;syncM();updateLayerListUI();"><option value="MESH" ${
              l.visMode === "MESH" ? "selected" : ""
            }>Mesh (Surface)</option><option value="POINTS" ${
              l.visMode === "POINTS" ? "selected" : ""
            }>Points (Vector)</option></select></div><div class="row"><label>Shading Mode</label><select id="${shadingSelectId}" onchange="layers[${i}].shadingMode=this.value;syncM();"><option value="SPECULAR" ${
              l.shadingMode === "SPECULAR" ? "selected" : ""
            }>Default (Specular)</option><option value="HEIGHT" ${
              l.shadingMode === "HEIGHT" ? "selected" : ""
            }>Height-Based</option><option value="VELOCITY" ${
              l.shadingMode === "VELOCITY" ? "selected" : ""
            }>Velocity Gradient</option><option value="ENERGY" ${
              l.shadingMode === "ENERGY" ? "selected" : ""
            }>Heatmap (Energy)</option><option value="DIVERGENCE" ${
              l.shadingMode === "DIVERGENCE" ? "selected" : ""
            }>Divergence (Red/Blue)</option><option value="VECTOR_RGB" ${
              l.shadingMode === "VECTOR_RGB" ? "selected" : ""
            }>Vector RGB</option></select></div>${pointSizeControls}<label>Grad. Bias: <span id="l-gb_${
              l.id
            }" class="value-label">${l.gradientBias.toFixed(
              2,
            )}</span></label><input type="range" id="i-gb-${
              l.id
            }" min="-1.0" max="1.0" step="0.05" value="${
              l.gradientBias
            }"><label>Grad. Contrast: <span id="l-gc_${
              l.id
            }" class="value-label">${l.gradientContrast.toFixed(
              1,
            )}</span></label><input type="range" id="i-gc-${l.id}" min="0.1" max="5.0" step="0.1" value="${
              l.gradientContrast
            }"></div>`;
            d.appendChild(b);

            const cInputEl = $(cInputId);
            const lCEl = $(`l-c-${l.id}`);
            if (cInputEl) {
              cInputEl.classList.add("custom-drag-slider");
              cInputEl.oninput = function () {
                layers[i].C = +this.value;
                lCEl.innerText = layers[i].C.toFixed(3);
              };
            }
            const dInputEl = $(dInputId);
            const lDEl = $(`l-d-${l.id}`);
            if (dInputEl) {
              dInputEl.classList.add("custom-drag-slider");
              dInputEl.oninput = function () {
                layers[i].D = +this.value;
                lDEl.innerText = layers[i].D.toFixed(3);
              };
            }
            const kInputEl = $(kInputId);
            const lKEl = $(`l-k-${l.id}`);
            if (kInputEl) {
              kInputEl.classList.add("custom-drag-slider");
              kInputEl.oninput = function () {
                layers[i].K = +this.value;
                lKEl.innerText = layers[i].K.toFixed(3);
              };
            }

            const iGbEl = $(`i-gb-${l.id}`);
            if (iGbEl) {
              iGbEl.classList.add("custom-drag-slider");
              iGbEl.oninput = function () {
                layers[i].gradientBias = parseFloat(this.value);
                document.getElementById(`l-gb_${l.id}`).innerText = parseFloat(
                  this.value,
                ).toFixed(2);
                syncM();
              };
            }
            const iGcEl = $(`i-gc-${l.id}`);
            if (iGcEl) {
              iGcEl.classList.add("custom-drag-slider");
              iGcEl.oninput = function () {
                layers[i].gradientContrast = parseFloat(this.value);
                document.getElementById(`l-gc_${l.id}`).innerText = parseFloat(
                  this.value,
                ).toFixed(1);
                syncM();
              };
            }

            $(`i-psz-${l.id}`).classList.add("custom-drag-slider");
            $(`i-psc-${l.id}`).classList.add("custom-drag-slider");
            $(`i-pf-${l.id}`).classList.add("custom-drag-slider");
          });
        }
        restoreExpansionState(expansionState);
        setupCustomSliderDrag();
      }

      function updateUI() {
        const is3D = IS_3D_MODE;

        $("volume-settings-group-sidebar").style.display = is3D
          ? "block"
          : "none";
        $("vol-controls-toolbar").style.display = is3D ? "flex" : "none";
        $("i-gap").style.display = is3D ? "none" : "block";
        $("l-gap").parentElement.style.display = is3D ? "none" : "block";
        $("btn-vol").style.display = is3D ? "none" : "block";
        $("3d-cam-controls").style.display = is3D ? "flex" : "none";
        $("global-coupling-group").style.display = is3D ? "none" : "block";

        const volControlsSidebar = $("vol-controls-sidebar");
        if (volControlsSidebar) {
          volControlsSidebar.style.display = is3D ? "block" : "none";
        }

        updateLayerListUI();
        renderCouplingMatrixUI();
        renderDynamicBrushControls();
        renderVolGradientControls();
        updateProbeMenuUI();

        $("l-exposure").innerText = EXPOSURE.toFixed(2);
        $("l-gap").innerText = GAP;
        $("l-z").innerText = ZSC.toFixed(1);
        $("l-li").innerText = lInt;
        $("l-refl").innerText = REFLECTIVITY.toFixed(2);
        $("l-vo").innerText = parseFloat($("i-vo").value).toFixed(2);
        $("l-vd").innerText = VOL_LAYERS;
        $("l-psz").innerText = BASE_POINT_SETTINGS.pointSize.toFixed(1);
        $("l-psc").innerText = BASE_POINT_SETTINGS.pointScaleFactor.toFixed(1);
        $("l-pf").innerText = BASE_POINT_SETTINGS.pointFalloff.toFixed(2);

        updateSimControls();
        updVis();
      }
      
      function updateProbeMenuUI() {
          const histLenEl = $('probe-hist-len');
          const srEl = $('probe-sample-rate');
          const startMarkerEl = $('probe-start-marker');
          const endMarkerEl = $('probe-end-marker');
          
          histLenEl.max = MAX_HISTORY_LENGTH;
          
          if (histLenEl) {
              PROBE_HISTORY_LENGTH = Math.min(MAX_HISTORY_LENGTH, PROBE_HISTORY_LENGTH);
              histLenEl.value = PROBE_HISTORY_LENGTH;
              $('probe-hist-v').innerText = PROBE_HISTORY_LENGTH;
              histLenEl.classList.add("custom-drag-slider");
          }
          if (srEl) {
              srEl.value = PROBE_SAMPLE_RATE;
              $('probe-sr-v').innerText = PROBE_SAMPLE_RATE;
              srEl.classList.add("custom-drag-slider");
          }
          
          const currentLength = PROBE_HISTORY_LENGTH; 
          
          startMarkerEl.max = currentLength;
          endMarkerEl.max = currentLength;
          
          if (LOOP_END_IDX === 0 || LOOP_END_IDX > currentLength) { 
              LOOP_END_IDX = currentLength; 
          }
          LOOP_START_IDX = Math.min(LOOP_START_IDX, LOOP_END_IDX);

          startMarkerEl.value = LOOP_START_IDX;
          endMarkerEl.value = LOOP_END_IDX;
          
          updateMarkers(endMarkerEl);
          
          $('cb-probe-loop').checked = IS_LOOPING;
      }

      function setupSDFMenuDrag() {
        const sdfMenu = $("sdf-menu");
        let isDraggingMenu = false;
        let startX, startY, startLeft, startTop;

        sdfMenu.onmousedown = (e) => {
          if (
            e.target.tagName !== "INPUT" &&
            e.target.tagName !== "SELECT" &&
            e.target.tagName !== "BUTTON" &&
            e.target.id !== "sdf-preview"
          ) {
            isDraggingMenu = true;
            startX = e.clientX;
            startY = e.clientY;
            const rect = sdfMenu.getBoundingClientRect();
            startLeft = rect.left;
            startTop = rect.top;
            sdfMenu.style.cursor = "grabbing";
            e.stopPropagation();
          }
        };

        window.addEventListener("mousemove", (e) => {
          if (!isDraggingMenu) return;
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;

          let newLeft = startLeft + dx;
          let newTop = startTop + dy;

          newLeft = Math.max(
            0,
            Math.min(window.innerWidth - sdfMenu.offsetWidth, newLeft),
          );
          newTop = Math.max(
            0,
            Math.min(window.innerHeight - sdfMenu.offsetHeight, newTop),
          );

          sdfMenu.style.left = `${newLeft}px`;
          sdfMenu.style.top = `${newTop}px`;
        });

        window.addEventListener("mouseup", () => {
          if (isDraggingMenu) {
            isDraggingMenu = false;
            sdfMenu.style.cursor = "grab";
          }
        });
      }
      
      function setupProbeMenuDrag() {
          const probeMenu = $("probe-menu");
          let isDraggingMenu = false;
          let startX, startY, startLeft, startTop;

          probeMenu.onmousedown = (e) => {
              if (
                  e.target.tagName !== "INPUT" &&
                  e.target.tagName !== "SELECT" &&
                  e.target.tagName !== "BUTTON" &&
                  e.target.id !== "probe-graph-canvas"
              ) {
                  isDraggingMenu = true;
                  startX = e.clientX;
                  startY = e.clientY;
                  const rect = probeMenu.getBoundingClientRect();
                  startLeft = rect.left;
                  startTop = rect.top;
                  probeMenu.style.cursor = "grabbing";
                  e.stopPropagation();
              }
          };

          window.addEventListener("mousemove", (e) => {
              if (!isDraggingMenu) return;
              const dx = e.clientX - startX;
              const dy = e.clientY - startY;

              let newLeft = startLeft + dx;
              let newTop = startTop + dy;

              newLeft = Math.max(
                  0,
                  Math.min(window.innerWidth - probeMenu.offsetWidth, newLeft),
              );
              newTop = Math.max(
                  $("top-toolbar").offsetHeight,
                  Math.min(window.innerHeight - probeMenu.offsetHeight, newTop),
              );

              probeMenu.style.left = `${newLeft}px`;
              probeMenu.style.top = `${newTop}px`;
          });

          window.addEventListener("mouseup", () => {
              if (isDraggingMenu) {
                  isDraggingMenu = false;
                  probeMenu.style.cursor = "grab";
              }
          });
      }

      function setupEmitMenuDrag() {
        const emitMenu = $("emit-menu");
        let isDraggingEmitMenu = false;
        let startX, startY, startLeft, startTop;

        emitMenu.onmousedown = (e) => {
          if (
            e.target.tagName !== "INPUT" &&
            e.target.tagName !== "SELECT" &&
            e.target.tagName !== "BUTTON"
          ) {
            isDraggingEmitMenu = true;
            startX = e.clientX;
            startY = e.clientY;
            const rect = emitMenu.getBoundingClientRect();
            startLeft = rect.left;
            startTop = rect.top;
            emitMenu.style.cursor = "grabbing";
            e.stopPropagation();
          }
        };

        window.addEventListener("mousemove", (e) => {
          if (!isDraggingEmitMenu) return;
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;

          let newLeft = startLeft + dx;
          let newTop = startTop + dy;

          newLeft = Math.max(
            0,
            Math.min(window.innerWidth - emitMenu.offsetWidth, newLeft),
          );
          newTop = Math.max(
            $("top-toolbar").offsetHeight,
            Math.min(window.innerHeight - emitMenu.offsetHeight, newTop),
          );

          emitMenu.style.left = `${newLeft}px`;
          emitMenu.style.top = `${newTop}px`;
        });

        window.addEventListener("mouseup", () => {
          if (isDraggingEmitMenu) {
            isDraggingEmitMenu = false;
            emitMenu.style.cursor = "grab";
          }
        });
      }
      
      function setupValveMenuDrag() {
        const valveMenu = $("valve-menu");
        let isDraggingValveMenu = false;
        let startX, startY, startLeft, startTop;

        valveMenu.onmousedown = (e) => {
          if (
            e.target.tagName !== "INPUT" &&
            e.target.tagName !== "SELECT" &&
            e.target.tagName !== "BUTTON"
          ) {
            isDraggingValveMenu = true;
            startX = e.clientX;
            startY = e.clientY;
            const rect = valveMenu.getBoundingClientRect();
            startLeft = rect.left;
            startTop = rect.top;
            valveMenu.style.cursor = "grabbing";
            e.stopPropagation();
          }
        };

        window.addEventListener("mousemove", (e) => {
          if (!isDraggingValveMenu) return;
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;

          let newLeft = startLeft + dx;
          let newTop = startTop + dy;

          newLeft = Math.max(
            0,
            Math.min(window.innerWidth - valveMenu.offsetWidth, newLeft),
          );
          newTop = Math.max(
            $("top-toolbar").offsetHeight,
            Math.min(window.innerHeight - valveMenu.offsetHeight, newTop),
          );

          valveMenu.style.left = `${newLeft}px`;
          valveMenu.style.top = `${newTop}px`;
        });

        window.addEventListener("mouseup", () => {
          if (isDraggingValveMenu) {
            isDraggingValveMenu = false;
            valveMenu.style.cursor = "grab";
          }
        });
      }
let customSliderHandleMouseMove;
      let customSliderHandleMouseUp;

      function setupCustomSliderDrag() {
        const sliders = document.querySelectorAll('input[type="range"]');
        sliders.forEach((slider) => {
          slider.classList.add("custom-drag-slider");
        });

        let activeSlider = null;
        let startX = 0;
        let startValue = 0;
        const sensitivity = 250;

        const updateSliderValue = (e) => {
          if (!activeSlider) return;

          const min = parseFloat(activeSlider.min || 0);
          const max = parseFloat(activeSlider.max || 1);
          const step = parseFloat(activeSlider.step || 0.01);
          const range = max - min;

          const dx = e.clientX - startX;
          const valueChange = (dx / sensitivity) * range;

          let newValue = startValue + valueChange;

          newValue = Math.max(min, Math.min(max, newValue));

          newValue = Math.round(newValue / step) * step;

          activeSlider.value = newValue;

          const event = new Event("input", { bubbles: true });
          activeSlider.dispatchEvent(event);
        };

        customSliderHandleMouseMove = (e) => {
          e.preventDefault();
          if (activeSlider) {
            updateSliderValue(e);
          }
        };

        customSliderHandleMouseUp = () => {
          if (activeSlider) {
            const changeEvent = new Event("change", { bubbles: true });
            activeSlider.dispatchEvent(changeEvent);
            activeSlider = null;
            document.body.style.cursor = "default";
          }
          window.removeEventListener("mousemove", customSliderHandleMouseMove);
          window.removeEventListener("mouseup", customSliderHandleMouseUp);
        };

        const handleMouseDown = (e) => {
          if (e.target.tagName !== "INPUT" || e.target.type !== "range") return;

          if (e.target.classList.contains("custom-drag-slider")) {
            activeSlider = e.target;
            startX = e.clientX;
            startValue = parseFloat(activeSlider.value);

            document.body.style.cursor = "ew-resize";
            window.addEventListener("mousemove", customSliderHandleMouseMove);
            window.addEventListener("mouseup", customSliderHandleMouseUp);
            e.preventDefault();
          } else {
            activeSlider = null;
          }
        };

        document.querySelectorAll(".custom-drag-slider").forEach((slider) => {
          slider.removeEventListener("mousedown", handleMouseDown);
          slider.addEventListener("mousedown", handleMouseDown);
        });
      }
function setupDragPlane(mesh, hitPoint, event) {
    const mouse = nm(event);
    raycaster.setFromCamera(mouse, camera);

    const camToPoint = new THREE.Vector3().subVectors(mesh.position, camera.position).normalize();
    dragPlane.setFromNormalAndCoplanarPoint(camToPoint, mesh.position);
}

var dragStartY_Screen = 0; // NEW: Screen Y start position
var dragStartLIdx = -1; // NEW: Item LIdx at drag start
function setupScene() {
        canvasContainer = $("canvas-container");
        const W = canvasContainer.clientWidth;
        const H = canvasContainer.clientHeight;
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x1a1d21, 50, 150);
        camera = new THREE.PerspectiveCamera(75, W / H, 0.1, 1000);
        TGT.set(0, 0, 0);
        updCam();
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(W, H);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.sortObjects = false;
        canvasContainer.appendChild(renderer.domElement);
        raycaster = new THREE.Raycaster();
        raycaster.layers.set(0);
        scene.add(new THREE.AmbientLight(0x404040));
        scene.add(new THREE.DirectionalLight(0xffffff, 0.6));
        window.addEventListener("resize", onResize, false);

        canvasContainer.addEventListener("mousedown", (e) => {
          if (e.button === 2) {
            isOrbit = true;
            mX = e.clientX;
            mY = e.clientY;
            return;
          }
          if (e.button === 1 || e.shiftKey) {
            isOrbit = true;
            mX = e.clientX;
            mY = e.clientY;
            return;
          }

          const hit = cast(e);

          const isEmitterMode = brush === "EMITTER_PLACE";
          const isValveMode = brush === "VALVE_PLACE";
          const isEmitterHit = hit && hit.type === "EMITTER" && hit.obj && hit.obj.userData.eid;
          const isValveHit = hit && hit.type === "VALVE" && hit.obj && hit.obj.userData.eid;
          
          if (isEmitterHit || isValveHit) {
            const item = isEmitterHit ? emits.find((x) => x.id === hit.obj.userData.eid) : VALVES.find((x) => x.id === hit.obj.userData.eid);
            const mesh = hit.obj;

            selectedEmitterId = isEmitterHit ? item.id : null;
            selectedValveId = isValveHit ? item.id : null;
            actEmitPart = isEmitterHit ? hit.obj.userData.part : "BODY";
            updateEmitterInspector();
            updateValveInspector();
            syncE();

            isDrag = true;
            dragMode = null; // Will be set on first mousemove
            dragStartLayerIdx = item.lIdx;
            dragStartY_Screen = e.clientY; // NEW
            dragStartLIdx = item.lIdx; // NEW

            if (mesh) {
              if (!IS_3D_MODE) {
                dragPlane.setComponents(0, -1, 0, mesh.position.y);
              } else {
                // Initialize dragPlane to the Layer Plane (XZ plane)
                dragPlane.setFromNormalAndCoplanarPoint(new THREE.Vector3(0, 1, 0), mesh.position);
              }

              const mouse = nm(e);
              raycaster.setFromCamera(mouse, camera);
              let planeHit = new THREE.Vector3();
              
              if (raycaster.ray.intersectPlane(dragPlane, planeHit)) {
                dragStartOffset.subVectors(planeHit, mesh.position);
              } else {
                dragStartOffset.set(0, 0, 0);
              }

              dragStartGridCoords.mX = e.clientX; 
              dragStartGridCoords.mY = e.clientY; 
            }
            return;
          }

          if (selectedEmitterId) {
            selectedEmitterId = null;
            updateEmitterInspector();
            syncE();
          }
          if (selectedValveId) {
            selectedValveId = null;
            updateValveInspector();
            syncE();
          }

          if (e.button === 0) {
            if (
              brush === "SDF_PLACE" &&
              hit &&
              $("sdf-menu").style.display === "block"
            ) {
              let i = hit.i,
                j = hit.j;
              let lIdx =
                hit.lIdx !== undefined
                  ? hit.lIdx
                  : layers.findIndex((l) => l.intr) || 0;
              if (IS_3D_MODE) {
                i = GRID / 2;
                j = GRID / 2;
              }
              placeShape(i, j, lIdx);
              return;
            }

            if (brush === "DISTURBANCE" && hit && hit.point) {
              pulseStartTime = TIME;
              interact(hit.i, hit.j, hit.lIdx);
              activeBrushHit = hit;
              isContinuousBrushActive = true;
              isDrag = true;
            } else if (brush === "DENSITY_PAINT" && hit && hit.point) {
              const targetLIdx = hit.lIdx !== undefined ? hit.lIdx : -1;
              interact(hit.i, hit.j, targetLIdx);
              isContinuousBrushActive = true;
              isDrag = true;
              activeBrushHit = { i: hit.i, j: hit.j, lIdx: targetLIdx };
            } else if (brush === "EMITTER_PLACE" || brush === "VALVE_PLACE") {
              if (!hit) return;

              let targetLIdx = IS_3D_MODE
                ? Math.floor(layers.length / 2)
                : hit.lIdx;
              let startI = hit.i;
              let startJ = hit.j;
              if (IS_3D_MODE) {
                startI = GRID / 2;
                startJ = GRID / 2;
              }

              if (brush === "VALVE_PLACE") {
                  const newValve = {
                      ...BASE_VALVE_CFG,
                      id: Date.now() + Math.random(),
                      i: startI,
                      j: startJ,
                      lIdx: targetLIdx,
                      isKeyPressed: false,
                  };
                  VALVES.push(newValve);
                  selectedValveId = newValve.id;
                  updateValveInspector();
                  syncM();
              } else {
                  emits.push({
                    ...BASE_PROBE_CFG,
                    id: Date.now(),
                    type: "EMITTER_LINE_DRAG",
                    shp: $("em-shp").value,
                    st: parseFloat($("em-st").value),
                    rt: parseFloat($("i-em-rt").value),
                    off: parseFloat($("i-em-of").value),
                    geo: "POINT",
                    i: startI,
                    j: startJ,
                    lIdx: targetLIdx,
                    i2: startI,
                    j2: startJ,
                  });

                  selectedEmitterId = emits[emits.length - 1].id;
                  actEmitPart = "BODY";
                  updateEmitterInspector();
              }

              syncE();
              isDrag = true;

              const newMesh = emitMeshes.find(
                (m) => m.userData.eid === (selectedEmitterId || selectedValveId),
              );
              if (newMesh && !IS_3D_MODE) {
                dragPlane.setComponents(0, -1, 0, newMesh.position.y);
                dragStartOffset.set(0, 0, 0);
              }
            }
          }
        });

        canvasContainer.addEventListener("mousemove", (e) => {
          const dx = e.clientX - mX;
          const dy = e.clientY - mY;
          mX = e.clientX;
          mY = e.clientY;

          if (isOrbit) {
            theta -= dx * 0.5;
            phi -= dy * 0.5;
            updCam();
            return;
          }

          if (!isDrag && brush !== "SDF_PLACE") return;

          const hit = cast(e);

          if (
            brush === "SDF_PLACE" &&
            $("sdf-menu").style.display === "block"
          ) {
            if (hit && !IS_3D_MODE) {
              sdfPlacementGrid = { i: hit.i, j: hit.j, lIdx: hit.lIdx };
            } else if (IS_3D_MODE) {
              sdfPlacementGrid = {
                i: GRID / 2,
                j: GRID / 2,
                lIdx: Math.floor(layers.length / 2),
              };
            }
            updateStampPreview();
          }

          if (isDrag && (selectedEmitterId || selectedValveId)) {
            const isEmitter = !!selectedEmitterId;
            const item = isEmitter ? emits.find((x) => x.id === selectedEmitterId) : VALVES.find((x) => x.id === selectedValveId);
            if (!item) return;
            
            const mesh = emitMeshes.find(m => m.userData.eid === (selectedEmitterId || selectedValveId));
            if (!mesh) return;


            const mouse = nm(e);
            raycaster.setFromCamera(mouse, camera);

            let newPos = new THREE.Vector3();
            let intersection;
            
            const layerSpacing = getLayerSpacing();
            const totalHeight = (layers.length - 1) * layerSpacing;
            const centerYOffset = IS_3D_MODE ? totalHeight / 2 : 0;
            const layerHeightTotal = layers.length;

            if (IS_3D_MODE) {
                
                if (!dragMode) {
                    const absDx = Math.abs(e.clientX - dragStartGridCoords.mX);
                    const absDy = Math.abs(e.clientY - dragStartGridCoords.mY);
                    const threshold = 5; 

                    if (absDx > threshold || absDy > threshold) {
                        // Use a slightly weighted check to prevent accidental vertical lock
                        if (absDy > absDx) { 
                            dragMode = 'VERTICAL';
                            // No need to define a 3D intersection plane for vertical drag!
                        } else {
                            dragMode = 'LATERAL';
                            // Reset to the Layer Plane (XZ plane)
                            const layerMesh = meshes.find(m => m.userData.idx === dragStartLayerIdx);
                            if (layerMesh) {
                               dragPlane.setFromNormalAndCoplanarPoint(new THREE.Vector3(0, 1, 0), layerMesh.position);
                            }
                            
                            // Recalculate offset based on the *new* plane definition
                            let initialPlaneHit = new THREE.Vector3();
                            raycaster.ray.intersectPlane(dragPlane, initialPlaneHit);
                            dragStartOffset.subVectors(initialPlaneHit, mesh.position);
                        }
                    }
                }
                
                if (dragMode === 'LATERAL') {
                    intersection = raycaster.ray.intersectPlane(dragPlane, newPos);
                } else if (dragMode === 'VERTICAL') {
                    // *** FIX: Direct mapping of screen Y to Layer Index ***
                    const screenDeltaY = e.clientY - dragStartY_Screen;
                    
                    // Simple heuristic: map screen-space vertical movement to layer change.
                    // A movement of 50-100 pixels should roughly map to one layer step,
                    // but we need to estimate the screen size of one layer.
                    
                    // Project the layer spacing onto screen space to find the sensitivity
                    const targetWorldY = gtw(item.i, item.j, 0).y;
                    const screenY0 = new THREE.Vector3(0, targetWorldY, 0).project(camera).y;
                    const screenY1 = new THREE.Vector3(0, targetWorldY - layerSpacing, 0).project(camera).y;
                    const screenLayerHeight = Math.abs(screenY1 - screenY0) * (H / 2); // screen height of one layer
                    
                    // If the item is far away, screenLayerHeight might be tiny, or large if close.
                    // Use a safe minimum screen movement needed to trigger a layer change (e.g., 20px)
                    const layerSensitivity = Math.max(20, screenLayerHeight * 0.5); 
                    
                    // Calculate the number of layers to move based on total screen drag
                    let layerDelta = Math.round(screenDeltaY / layerSensitivity);
                    
                    let newLIdx = dragStartLIdx + layerDelta;
                    
                    newLIdx = Math.max(0, Math.min(layerHeightTotal - 1, newLIdx));
                    
                    // Update the item's LIdx directly
                    item.lIdx = newLIdx;
                    if (item.i2 !== undefined) {
                        item.lIdx = newLIdx; 
                    }
                    
                    // Set intersection to true so the update logic runs
                    intersection = true;

                    // The actual world position for syncE() is calculated via gtw(i, j, lIdx), 
                    // which is implicitly done below. We don't need to touch newPos.x/z.
                }

            } else { // 2D Mode (Layer Plane always)
                intersection = raycaster.ray.intersectPlane(dragPlane, newPos);
                dragMode = 'LATERAL';
            }


            if (intersection) {
              
              if (dragMode === 'VERTICAL') {
                  // No need to calculate newPos for coordinates here, as only LIdx changed.
                  // We skip newPos.sub(dragStartOffset) and the XZ grid calculation.
              } else { // LATERAL (2D or 3D)
                newPos.sub(dragStartOffset);
                
                // Snap World Y position to the current layer's Y coordinate
                const layerMesh = meshes.find(m => m.userData.idx === item.lIdx);
                if (layerMesh) {
                    newPos.y = layerMesh.position.y;
                }
                
                // Convert world XZ to grid J/I
                const gridI = Math.min(
                    GRID - 1,
                    Math.max(0, ((newPos.z + 25) / 50) * GRID) | 0,
                );
                const gridJ = Math.min(
                    GRID - 1,
                    Math.max(0, ((newPos.x + 25) / 50) * GRID) | 0,
                );

                if (isEmitter) {
                    if (item.geo === "LINE" && !item.isProbe) {
                      if (actEmitPart === "START") {
                        item.i = gridI;
                        item.j = gridJ;
                      } else if (actEmitPart === "END") {
                        item.i2 = gridI;
                        item.j2 = gridJ;
                      } else {
                        const centerI = (item.i + item.i2) / 2;
                        const centerJ = (item.j + item.j2) / 2;
                        const deltaI = gridI - centerI;
                        const deltaJ = gridJ - centerJ;

                        item.i = Math.round(item.i + deltaI);
                        item.j = Math.round(item.j + deltaJ);
                        item.i2 = Math.round(item.i2 + deltaI);
                        item.j2 = Math.round(item.j2 + deltaJ);
                      }
                    } else if (item.geo === "POINT" || item.isProbe) {
                      item.i = gridI;
                      item.j = gridJ;
                      item.i2 = gridI;
                      item.j2 = gridJ;
                    }
                } else { // Valve logic
                    item.i = gridI;
                    item.j = gridJ;
                }
              }


              item.i = Math.max(0, Math.min(GRID - 1, item.i));
              item.j = Math.max(0, Math.min(GRID - 1, item.j));
              if (item.i2 !== undefined) {
                item.i2 = Math.max(0, Math.min(GRID - 1, item.i2));
                item.j2 = Math.max(0, Math.min(GRID - 1, item.j2));
              }
            }
            syncE();
          }

          if (brush === "DISTURBANCE" || brush === "DENSITY_PAINT") {
            if (hit && hit.point) {
              const targetLIdx =
                hit.lIdx !== undefined
                  ? hit.lIdx
                  : activeBrushHit
                    ? activeBrushHit.lIdx
                    : -1;
              activeBrushHit = { i: hit.i, j: hit.j, lIdx: targetLIdx };
            }
          }
        });

        canvasContainer.addEventListener("mouseup", (e) => {
          isOrbit = false;
          isDrag = false;
          dragMode = null; // Reset drag mode

          if (e.button === 0) {
            const lastEmIdx = emits.findIndex(
              (e) => e.type === "EMITTER_LINE_DRAG",
            );
            if (lastEmIdx !== -1) {
              emits[lastEmIdx].type = "EMITTER";
              emits[lastEmIdx].geo = $("em-geo").value;
              if (emits[lastEmIdx].geo === "POINT") {
                emits[lastEmIdx].i2 = emits[lastEmIdx].i;
                emits[lastEmIdx].j2 = emits[lastEmIdx].j;
              }
              selectedEmitterId = emits[lastEmIdx].id;
              updateEmitterInspector();
              syncE();
            }
          }
          isContinuousBrushActive = false;
          activeBrushHit = null;
        });

        canvasContainer.addEventListener(
          "wheel",
          (e) => {
            e.preventDefault();
            rad *= e.deltaY > 0 ? 1.1 : 0.9;
            updCam();
          },
          { passive: false },
        );
      }

var updVis = () => {
        visMin = parseFloat($("i-vis-min").value);
        visMax = parseFloat($("i-vis-max").value);
        if (visMin > visMax) {
          if (document.activeElement.id === "i-vis-min") {
            visMax = visMin;
            $("i-vis-max").value = visMax;
          } else {
            visMin = visMax;
            $("i-vis-min").value = visMin;
          }
        }
        $("l-vism").innerText = `${visMin.toFixed(2)} - ${visMax.toFixed(2)}`;
        meshes.forEach((m) => {
          if (m.material.uniforms) {
            m.material.uniforms.VIS_MIN.value = visMin;
            m.material.uniforms.VIS_MAX.value = visMax;
          }
        });
      };
function setupSliderListeners() {
    $("i-res").onchange = (e) => {
        resizeSim(+e.target.value);
    };

    $("i-gap").oninput = (e) => {
        GAP = +e.target.value;
        $("l-gap").innerText = GAP;
        updTr();
        syncE();
    };
    $("i-z").oninput = (e) => {
        ZSC = +e.target.value;
        $("l-z").innerText = ZSC.toFixed(1);
    };
    $("i-li").oninput = (e) => {
        lInt = +e.target.value;
        $("l-li").innerText = lInt;
    };
    $("i-refl").oninput = (e) => {
        REFLECTIVITY = +e.target.value;
        $("l-refl").innerText = REFLECTIVITY.toFixed(2);
        syncM();
    };
    $("i-vo").oninput = (e) => {
        var op = parseFloat(e.target.value);
        $("l-vo").innerText = op.toFixed(2);
        syncM();
    };

    $("i-exposure").oninput = (e) => {
        EXPOSURE = parseFloat(e.target.value);
        $("l-exposure").innerText = EXPOSURE.toFixed(2);
        meshes.forEach((m) => {
            if (m.material.uniforms && m.material.uniforms.uExposure) {
                m.material.uniforms.uExposure.value = EXPOSURE;
            }
        });
    };

    $("cb-auto-exposure").onchange = (e) => {
        AUTO_EXPOSURE = e.target.checked;
        $("i-exposure").disabled = AUTO_EXPOSURE;
    };

    const iVd = $("i-vd");
    if (iVd) {
        iVd.oninput = (e) => {
            VOL_LAYERS = +e.target.value;
            $("l-vd").innerText = VOL_LAYERS;
            if (IS_3D_MODE) {
                layers = [];
                for (let k = 0; k < VOL_LAYERS; k++) {
                    layers.push(defL(layerCounter++));
                }
                initData();
            }
        };
    }
    const cbShowDen = $("cb-show-den");
    if (cbShowDen) {
        cbShowDen.onchange = (e) => {
            SHOW_DENSITY = e.target.checked;
            syncM();
        };
        SHOW_DENSITY = cbShowDen.checked;
    }

    const cbVolBox = $("cb-vol-box");
    if (cbVolBox) {
        cbVolBox.onchange = (e) => {
            SHOW_VOL_WIREFRAME = e.target.checked;
            updateVolumeBox();
        };
    }

    const cbModAlpha = $("cb-mod-alpha");
    if (cbModAlpha) {
        cbModAlpha.onchange = (e) => {
            IS_ALPHA_MODULATION = e.target.checked;
            syncM();
        };
        IS_ALPHA_MODULATION = cbModAlpha.checked;
    }
    const cbVolAbsorb = $("cb-vol-absorb");
    if (cbVolAbsorb) {
        cbVolAbsorb.onchange = (e) => {
            IS_VOL_ABSORBING_BND = e.target.checked;
        };
        cbVolAbsorb.checked = IS_VOL_ABSORBING_BND; 
    }
    const iPsz = $("i-psz");
    const lPsz = $("l-psz");
    if (iPsz && lPsz) {
        iPsz.oninput = (e) => {
            BASE_POINT_SETTINGS.pointSize = parseFloat(e.target.value);
            lPsz.innerText = BASE_POINT_SETTINGS.pointSize.toFixed(1);
            layers.forEach(
                (l) => (l.pointSize = BASE_POINT_SETTINGS.pointSize),
            );
            meshes.forEach((m) => {
                if (m.material.uniforms)
                    m.material.uniforms.uPointSize.value =
                        BASE_POINT_SETTINGS.pointSize;
            });
        };
    }
    const iPsc = $("i-psc");
    const lPsc = $("l-psc");
    if (iPsc && lPsc) {
        iPsc.oninput = (e) => {
            BASE_POINT_SETTINGS.pointScaleFactor = parseFloat(e.target.value);
            lPsc.innerText = BASE_POINT_SETTINGS.pointScaleFactor.toFixed(1);
            layers.forEach(
                (l) =>
                    (l.pointScaleFactor = BASE_POINT_SETTINGS.pointScaleFactor),
            );
            meshes.forEach((m) => {
                if (m.material.uniforms)
                    m.material.uniforms.uPointScaleFactor.value =
                        BASE_POINT_SETTINGS.pointScaleFactor;
            });
        };
    }

    $("i-vis-min").oninput = updVis;
    $("i-vis-max").oninput = updVis;
    var sd = () => {
        var p = $("i-sp").value * 0.01745,
            y = $("i-sy").value * 0.01745;
        sunDir
            .set(
                Math.sin(p) * Math.sin(y),
                Math.cos(p),
                Math.sin(p) * Math.cos(y),
            )
            .normalize();
    };
    $("i-sp").oninput = sd;
    $("i-sy").oninput = sd;
    sd();

    EV("i-gden-abs", "input", updateSimControls);
    EV("i-gden-ref", "input", updateSimControls);
    EV("i-sim-steps", "input", updateSimControls);
    EV("i-audio-buffer", "change", updateSimControls);
    EV("btn-reset-global-den", "click", resetGlobalDensity);

    ["b-dist", "b-emit", "b-valve", "b-den", "b-sdf"].forEach((id) => {
        const btn = $(id);
        btn.onclick = function () {
            ["b-dist", "b-emit", "b-valve", "b-den", "b-sdf"].forEach(
                (b) => ($(b).className = ""),
            );
            this.className = "active";
            brush = btn.dataset.brush;
            const isSDF = brush === "SDF_PLACE";
            $("sdf-menu").style.display = isSDF ? "block" : "none";
            $("valve-menu").style.display = "none";
            $("emit-menu").style.display = "none";

            if (isSDF) {
                updateSDFControls();
                renderSDFPreview();
                updateStampPreview();
            } else {
                disposeMesh(stampPreviewMesh);
                stampPreviewMesh = null;
            }

            if (id !== "b-emit") {
                selectedEmitterId = null;
                updateEmitterInspector();
            }
            if (id !== "b-valve") {
                selectedValveId = null;
                updateValveInspector();
            }

            syncM();

            renderDynamicBrushControls();
        };
    });
}
function setupGlobalEvents() {
    setupEmitMenuDrag();
    setupValveMenuDrag();

    window.addEventListener("keydown", (e) => {
      // Prevent default actions for F3, Delete, Backspace
      if (e.key === "F3") {
        e.preventDefault();
        document.body.classList.toggle("cinematic-mode");
        onResize();
      }
      if (
        (e.key === "Delete" || e.key === "Backspace") &&
        (selectedEmitterId || selectedValveId)
      ) {
        e.preventDefault();
        if (selectedEmitterId) deleteSelectedEmitter();
        if (selectedValveId) deleteSelectedValve();
      }
      
      let needsSync = false;

      // Handle Valve Key Interaction
      const valve = VALVES.find((v) => v.key === e.code);
      if (valve && !valve.isKeyPressed) {
          valve.isKeyPressed = true;
          needsSync = true;
          if (valve.id === selectedValveId) updateValveMenuInfo();
      }
      
      // Handle Emitter Key Interaction (FIXED LOGIC)
      emits.forEach((em) => {
          if (em.controlMode === "KEY_ACTIVATED" && em.key === e.code && !em.isKeyPressed) {
              em.isKeyPressed = true;
              needsSync = true;
              if (em.id === selectedEmitterId) updateEmitterMenuInfo();
          }
      });
      
      if (needsSync) {
          syncE();
      }
    });

    window.addEventListener("keyup", (e) => {
        let needsSync = false;

        // Handle Valve Key Interaction
        const valve = VALVES.find((v) => v.key === e.code);
        if (valve && valve.isKeyPressed) {
            valve.isKeyPressed = false;
            needsSync = true;
            if (valve.id === selectedValveId) updateValveMenuInfo();
        }

        // Handle Emitter Key Interaction (FIXED LOGIC)
        emits.forEach((em) => {
            if (em.controlMode === "KEY_ACTIVATED" && em.key === e.code && em.isKeyPressed) {
                em.isKeyPressed = false;
                needsSync = true;
                if (em.id === selectedEmitterId) updateEmitterMenuInfo();
            }
        });

        if (needsSync) {
            syncE();
        }
    });

    document.getElementById("sidebar").addEventListener("click", (e) => {
      const header = e.target.closest(".expandable-header");
      if (header) {
        if (
          e.target.tagName === "INPUT" ||
          e.target.tagName === "SELECT" ||
          e.target.tagName === "BUTTON"
        ) {
          return;
        }
        toggleExpand(header);
        e.preventDefault();
        e.stopPropagation();
      }
    });

    document
      .getElementById("sidebar")
      .addEventListener("mousedown", (e) => {
        if (
          e.target.tagName !== "INPUT" &&
          e.target.tagName !== "SELECT" &&
          e.target.tagName !== "TEXTAREA" &&
          e.target.tagName !== "BUTTON"
        ) {
          e.stopPropagation();
        }
      });

    EV("btn-toggle-ui", "click", () => {
      document.body.classList.toggle("cinematic-mode");
      if (document.body.classList.contains("cinematic-mode")) {
        $("emit-menu").style.display = "none";
        $("valve-menu").style.display = "none";
        $("sdf-menu").style.display = "none";
        $("probe-menu").style.display = "none";
        stopRealtimeAudio();
      }
      onResize();
    });

    EV("btn-toggle-play", "click", togglePlayPause);
    EV("btn-clear", "click", clearSimulation);
    EV("btn-reset-density", "click", resetDensity);
    EV("btn-reset-settings", "click", resetViewSettings);
    EV("btn-full-reset", "click", () =>
      fullResetConfig(DEFAULT_STATE_CONFIG),
    );
    EV("btn-add", "click", addLayer);
    EV("btn-rem", "click", removeLayer);

    EV("btn-cam-top", "click", () => setCameraView(45, 1, 60));
    EV("btn-cam-left", "click", () => setCameraView(135, 60, 60));
    EV("btn-cam-right", "click", () => setCameraView(315, 60, 60));
    EV("btn-cam-bottom", "click", () => setCameraView(45, 179, 60));
    EV("i-dt", "input", updateSimControls);
    EV("i-vis", "input", updateSimControls);

    EV("btn-save-preset", "click", savePresetFile);
    EV("btn-load-preset", "click", loadPresetFile);

    EV("btn-save-formula", "click", saveFormulaFile);
    EV("btn-load-formula", "click", loadFormulaFile);
    EV("btn-test-formula", "click", updateCustomFormula);
    EV("custom-name", "input", updateCustomFormula);
    EV("custom-vars", "input", updateCustomFormula);
    EV("custom-code", "input", updateCustomFormula);

    EV("btn-add-coupling", "click", addCouplingLink);

    const btnVol = $("btn-vol");
    if (btnVol)
      btnVol.onclick = () => {
        IS_3D_MODE = true;
        VOL_LAYERS = +$("i-vd").value;
        fullResetConfig({
          global: {
            ...DEFAULT_STATE_CONFIG.global,
            IS_3D_MODE: true,
            VOL_LAYERS: VOL_LAYERS,
          },
          layers: [],
          emits: [],
        });
        updateUI();
      };
    const btnExitVol = $("btn-exit-vol");
    if (btnExitVol)
      btnExitVol.onclick = () => {
        IS_3D_MODE = false;
        fullResetConfig({
          global: {
            ...DEFAULT_STATE_CONFIG.global,
            IS_3D_MODE: false,
            VOL_LAYERS: 40,
          },
          layers: DEFAULT_STATE_CONFIG.layers,
          emits: [],
        });
        updateUI();
      };
      
    EV("em-probe-toggle", "click", toggleEmitterProbe);
    EV("em-audio-btn", "click", () => {
        const menu = $("probe-menu");
        menu.style.display = 'block';
        updateProbeMenuUI();
        updateProbeMenuInfo();
    });
    
    EV("probe-close-btn", "click", () => {
        $("probe-menu").style.display = 'none';
        stopAudio();
    });
    
    EV("v-del-btn", "click", deleteSelectedValve);
    EV("v-close", "click", () => {
        selectedValveId = null;
        updateValveInspector();
        syncE();
    });
    
    EV("cb-probe-loop", "change", (e) => {
        IS_LOOPING = e.target.checked;
        if (IS_AUDIO_PLAYING) stopAudio();
    });

    EV("probe-save-wav", "click", () => {
        const maxAmp = PROBE_HISTORY.reduce((max, val) => Math.max(max, Math.abs(val)), 0);
        saveWavFile(PROBE_HISTORY, PROBE_SAMPLE_RATE, maxAmp);
    });
    
    EV("probe-hist-len", "input", (e) => {
        PROBE_HISTORY_LENGTH = +e.target.value;
        $('probe-hist-v').innerText = PROBE_HISTORY_LENGTH;
        while (PROBE_HISTORY.length > PROBE_HISTORY_LENGTH) {
            PROBE_HISTORY.shift();
        }
        updateProbeMenuUI();
        if (IS_AUDIO_PLAYING) stopAudio();
    });
    
    EV("probe-sample-rate", "input", (e) => {
        PROBE_SAMPLE_RATE = +e.target.value;
        $('probe-sr-v').innerText = PROBE_SAMPLE_RATE;
        setupAudio();
        if (IS_AUDIO_PLAYING) stopAudio();
        if (IS_REALTIME_AUDIO) stopRealtimeAudio();
    });
    
    EV("probe-play-btn", "click", () => {
        if (IS_AUDIO_PLAYING) {
            stopAudio();
            return;
        }
        if (PROBE_HISTORY.length === 0) {
            console.error("Cannot play audio: Probe history is empty."); 
            return;
        }
        stopRealtimeAudio();
        const maxAmp = PROBE_HISTORY.reduce((max, val) => Math.max(max, Math.abs(val)), 0);
        playAudio(PROBE_HISTORY, PROBE_SAMPLE_RATE, maxAmp);
    });

    EV("probe-live-btn", "click", () => {
        if (IS_REALTIME_AUDIO) {
            stopRealtimeAudio();
        } else {
            if (!ACTIVE_PROBE_ID) {
                console.error("Cannot start live mode: No probe selected or active.");
                return;
            }
            startRealtimeAudio();
        }
    });
    
    const startMarkerEl = $('probe-start-marker');
    const endMarkerEl = $('probe-end-marker');
    if (startMarkerEl && endMarkerEl) {
        startMarkerEl.oninput = () => updateMarkers(startMarkerEl);
        endMarkerEl.oninput = () => updateMarkers(endMarkerEl);
    }

    EV("em-st", "input", (e) => {
      $("em-st-v").innerText = (+e.target.value).toFixed(1);
      const em = emits.find((x) => x.id === editEmitId);
      if (em) em.st = +e.target.value;
    });
    EV("i-em-rt", "input", (e) => {
      $("em-rt-v").innerText = e.target.value;
      const em = emits.find((x) => x.id === editEmitId);
      if (em) em.rt = +e.target.value;
    });
    EV("i-em-of", "input", (e) => {
      $("em-of-v").innerText = e.target.value;
      const em = emits.find((x) => x.id === editEmitId);
      if (em) em.off = +e.target.value;
    });
    EV("em-shp", "change", (e) => {
      const em = emits.find((x) => x.id === editEmitId);
      if (em) em.shp = e.target.value;
    });
    EV("em-geo", "change", (e) => {
      const em = emits.find((x) => x.id === editEmitId);
      if (em) em.geo = e.target.value;
      syncE();
    });
    EV("em-del-btn", "click", deleteSelectedEmitter);
    EV("em-close", "click", () => {
      selectedEmitterId = null;
      updateEmitterInspector();
      syncE();
    });

    setupSDFMenuHandlers();
    setupSDFMenuDrag();
    setupProbeMenuDrag();
}


      function init() {
        setupGlobalEvents();
        setupSliderListeners();
        setupCustomSliderDrag();
        setupScene();
        loadSkybox();
        setupAudio();
        document.querySelector("#b-dist").click();
        updateCustomFormula();
        fullResetConfig(DEFAULT_STATE_CONFIG);
        updateUI();
        loop();
      }

      window.onload = init;
    </script>
</body>

</html>
