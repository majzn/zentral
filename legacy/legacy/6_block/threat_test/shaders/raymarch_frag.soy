#version 330 core
out vec4 fragCol;
in vec3 outPos;
in vec2 outUV;

uniform float pX;
uniform float pY;
uniform float pZ;
uniform float pPitch;
uniform float pPan;
uniform float resX;
uniform float resY;

#define M1 1597334677U /* 1719413*929 */
#define M2 3812015801U /* 140473*2467*11 */

#define MAX_MARCH 10000
#define MAX_DIST 10000.0
#define HIT_DIST 1.0

float NoiseHashFast(int x, int y) {
  uint ux = uint(x);
  uint uy = uint(y);
  ux *= M1; 
  uy *= M2;
  return float((ux ^ uy) * M1) * (1.0/float(uint(0xffffffffU)));
}

float NoiseValue2D(float x, float y) {
  int ix = int(floor(x));
  int iy = int(floor(y));
  float fx = (x - ix);
  float fy = (y - iy);
  float a = NoiseHashFast(ix, iy);
  float b = NoiseHashFast(ix + 1, iy);
  float c = NoiseHashFast(ix, iy + 1);
  float d = NoiseHashFast(ix + 1, iy + 1);
  float ux = (fx * fx * (3.0 - 2.0*fx));
  float uy = (fy * fy * (3.0 - 2.0*fy));
  return mix(a, b, ux) + (c - a) * uy * (1.0 - ux) + (d - b) * ux * uy;
}

float NoiseOctave2D(
    float x, float y, float scale, float persistance, int octaves) {
  float ret;
  float fx, fy;
  float freq = 1.0;
  float pers = 1.0;
  float acc = 0.0;
  int i;
  ret = 0.0;
  for(i = 0; i < octaves; i++) {
    fx = (x * scale) * freq;
    fy = (y * scale) * freq;
    ret += NoiseValue2D(fx, fy) * pers;
    acc += pers;
    freq *= 2.0;
    pers *= persistance;
  }
  return ret / acc;
}

float NoiseDomainWarp2D(
    float x, float y, float dx, float dy,
    float warp, float scale, float pers,
    int noiseOctaves, int warpOctaves) {
  float dwx = 
    NoiseOctave2D(x, y, scale, pers, warpOctaves);
  float dwy = 
    NoiseOctave2D(x + dx, y + dy, scale, pers, warpOctaves);
  return 
    NoiseOctave2D(x + warp*dwx, y + warp*dwy, scale, pers, noiseOctaves);
}

float SmoothSubtract(float d1, float d2, float k ) {
  float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );
  return mix( d2, -d1, h ) + k*h*(1.0-h);
}


vec4 Map(vec3 p) {
  vec3 c = vec3(0.0, 448.0, 0.0);
  float r = 0.1;
  float s = 0.001;
  float m = 1.0;
  float n = NoiseDomainWarp2D((p.x)*0.001, (p.z)*0.001,
    0.2f, 0.3f, 0.4f, 1.0f, 0.5f, 8, 4); 
  n *= 512.0;
#if 0
  n = sin(p.x*0.1 + p.z*0.1 + 3.14)*0.5 + 0.5;
  n *= 20.0;
  n += 1.0;
#endif
  float d = length(p - c) - r;
  return vec4(1.0, 1.0, 1.0, p.y - n);
}

vec4 RayMarch(vec3 rayOrig, vec3 rayDir) {
  float dist = 0.0;
  vec4 dS;
  for(int i = 0; i < MAX_MARCH; i++) {
    vec3 p = rayOrig + rayDir * dist;
    dS = Map(p);
    dist += dS.w;
    if(dist > MAX_DIST || dS.w < HIT_DIST) { break; }
  }
  return vec4(dS.x, dS.y, dS.z, dist);
}

mat3 rotateX(float theta) {
  float c = cos(theta);
  float s = sin(theta);
  return mat3(vec3(1, 0, 0), vec3(0, c, -s), vec3(0, s, c));
}

mat3 rotateY(float theta) {
  float c = cos(theta);
  float s = sin(theta);
  return mat3(vec3(c, 0, s), vec3(0, 1, 0), vec3(-s, 0, c));
}

mat3 rotateZ(float theta) {
  float c = cos(theta);
  float s = sin(theta);
  return mat3(vec3(c, -s, 0), vec3(s, c, 0), vec3(0, 0, 1));
}

vec3 GetNormal(vec3 p) {
  float d = Map(p).w;
  vec2 e = vec2(0.1, 0.0);
  vec3 n = d - vec3(
    Map(p - e.xyy).w,
    Map(p - e.yxy).w,
    Map(p - e.yyx).w);
  return normalize(n);
}

vec4 GetLight(vec3 p, vec3 col, vec3 pos) {
  vec3 lightPos = pos;
  vec3 l = lightPos;
  vec3 n = GetNormal(p);
  float dif = dot(n, l);
  return vec4(dif*col, dif);
}

void main() {
  vec2 res = vec2(resX, resY);
  float fov = 2.0f;
  vec2 uv = outUV - 0.5;
  uv.x *= (res.x / res.y)*fov;
  uv.y *= fov;
  vec4 finalCol = vec4(outPos.x, outPos.y, outPos.z, 1.0);
  vec3 ro = vec3(pX, pY, pZ)*1.0;
  vec3 rd = vec3(uv.x, -uv.y, 1.0);
  
  rd *= rotateX(pPitch);
  rd *= rotateY(pPan);
  
  vec4 march = RayMarch(ro, rd);
  vec3 p = ro + rd * march.w;
  
  if(march.w >= MAX_DIST) { discard; }
  if(march.w <= HIT_DIST) { discard; }
  
  vec3 ambient = vec3(0.05, 0.15, 0.2);
  vec3 background = vec3(0.03, 0.01, 0.04);
  
  vec3 lightDir = vec3(0.0, 0.7, 0.3);
  float diff = GetLight(p, vec3(1.0, 1.0, 1.0), lightDir).w;
  vec3 diffuse = diff*vec3(1.0, 1.0, 1.0);
  vec3 result = (ambient + diffuse) * vec3(1.0, 1.0, 1.0);
  
  fragCol = vec4(result, 1.0);

};

